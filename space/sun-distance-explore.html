<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ°æ—¥è·ç¦»æ¢ç´¢ - ä»åœ°çƒé£å‘å¤ªé˜³</title>
    <link rel="preconnect" href="https://fonts.loli.net">
    <link href="https://fonts.loli.net/css2?family=Noto+Sans+SC:wght@400;700;900&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            width: 100vw; height: 100vh;
        }

        /* ============ 3D Canvas ============ */
        #scene3d { width: 100vw; height: 100vh; display: block; cursor: grab; }
        #scene3d:active { cursor: grabbing; }

        /* ============ Overlay ============ */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* å·¦ä¸Šè§’è¿”å›æŒ‰é’® */
        .back-btn {
            position: absolute; top: 16px; left: 16px;
            color: rgba(255,255,255,0.5); text-decoration: none;
            font-size: 0.9rem; pointer-events: auto;
            padding: 6px 14px; border-radius: 20px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s;
        }
        .back-btn:hover { color: #fff; background: rgba(255,255,255,0.15); }

        /* é¡¶éƒ¨è·ç¦»è®¡æ•°å™¨ */
        .distance-counter {
            position: absolute; top: 20px; right: 24px;
            text-align: right;
        }
        .dist-value {
            font-family: 'Orbitron', monospace;
            font-size: 2.8rem; font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px rgba(100,180,255,0.5), 0 0 40px rgba(100,180,255,0.3);
            line-height: 1;
            letter-spacing: 2px;
        }
        .dist-unit {
            font-size: 1rem; color: rgba(255,255,255,0.5);
            margin-top: 4px;
        }
        .dist-label {
            font-size: 0.8rem; color: rgba(255,255,255,0.3);
            margin-top: 2px;
        }

        /* å·¦ä¾§é‡Œç¨‹ç¢‘é¢æ¿ */
        .milestone-panel {
            position: absolute; left: 16px; top: 50%;
            transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 8px;
        }
        .milestone-item {
            padding: 8px 14px;
            background: rgba(0,0,0,0.5);
            border-left: 3px solid rgba(255,255,255,0.15);
            border-radius: 0 8px 8px 0;
            font-size: 0.8rem;
            transition: all 0.3s;
            opacity: 0.5;
        }
        .milestone-item.active {
            border-left-color: #64b5f6;
            opacity: 1;
            background: rgba(100,180,255,0.1);
        }
        .milestone-item.passed {
            border-left-color: #ffd54f;
            opacity: 0.7;
        }
        .milestone-name { font-weight: 700; color: rgba(255,255,255,0.9); }
        .milestone-dist { font-size: 0.7rem; color: rgba(255,255,255,0.4); margin-top: 2px; }

        /* åº•éƒ¨æç¤º */
        .bottom-hint {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem; color: rgba(255,255,255,0.25);
            text-align: center;
        }

        /* åº•éƒ¨ç¼©æ”¾è¿›åº¦æ¡ */
        .zoom-bar-wrap {
            position: absolute; bottom: 50px; left: 50%;
            transform: translateX(-50%);
            width: 300px; max-width: 60vw;
        }
        .zoom-bar {
            width: 100%; height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px; position: relative;
        }
        .zoom-bar-fill {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, #ff7043, #ffd54f, #64b5f6);
            border-radius: 2px;
            transition: width 0.1s;
        }
        .zoom-bar-labels {
            display: flex; justify-content: space-between;
            font-size: 0.65rem; color: rgba(255,255,255,0.25);
            margin-top: 4px;
        }

        /* ============ Responsive ============ */
        @media (max-width: 600px) {
            .dist-value { font-size: 1.8rem; }
            .dist-unit { font-size: 0.85rem; }
            .distance-counter { top: 14px; right: 14px; }
            .milestone-panel { display: none; }
            .bottom-hint { font-size: 0.7rem; }
            .back-btn { font-size: 0.8rem; padding: 5px 10px; }
        }
    </style>
</head>
<body>

<div id="scene3d"></div>

<div class="overlay">
    <a class="back-btn" href="sun-distance.html">â† è¿”å›å¤ªç©ºèµ›è·‘</a>

    <div class="distance-counter">
        <div class="dist-value" id="distValue">0</div>
        <div class="dist-unit" id="distUnit">åƒç±³</div>
        <div class="dist-label">è·å¤ªé˜³è·ç¦»</div>
    </div>

    <div class="milestone-panel" id="milestonePanel"></div>

    <div class="zoom-bar-wrap">
        <div class="zoom-bar">
            <div class="zoom-bar-fill" id="zoomBarFill"></div>
        </div>
        <div class="zoom-bar-labels">
            <span>â˜€ï¸ å¤ªé˜³</span>
            <span>âœ¨ æ°´æ˜Ÿ</span>
            <span>ğŸŒ åœ°çƒ</span>
        </div>
    </div>

    <div class="bottom-hint" id="bottomHint">æ»šè½®ç¼©æ”¾ Â· æ‹–åŠ¨å¹³ç§» Â· å³é”®æ—‹è½¬ Â· è‡ªç”±æ¢ç´¢å¤ªé˜³åˆ°åœ°çƒ</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
// ============ å…¨å± 3D åœ°æ—¥è·ç¦»æ¢ç´¢ ============
(function() {
    const container = document.getElementById('scene3d');

    // ---- åœºæ™¯å¸¸é‡ ----
    // å¤ªé˜³åœ¨åŸç‚¹(0,0,0)ï¼Œåœ°çƒåœ¨è´ŸXæ–¹å‘(-300,0,0)
    const SCENE_LENGTH = 300;
    const REAL_DISTANCE = 149597870; // åœ°æ—¥è·ç¦» km
    const EARTH_R = 2;
    const SUN_R = 25;

    // é‡Œç¨‹ç¢‘æ•°æ®ï¼ˆè·å¤ªé˜³çš„è·ç¦»ï¼Œä¸‡kmï¼‰
    // æ°´æ˜Ÿè·å¤ªé˜³ 5790ä¸‡km = 5790ä¸‡km, é‡‘æ˜Ÿè·å¤ªé˜³ 10820ä¸‡km, åœ°çƒè·å¤ªé˜³ 14960ä¸‡km
    const MILESTONES = [
        { name: 'âœ¨ æ°´æ˜Ÿè½¨é“', distFromSunWanKm: 5790 },
        { name: 'ğŸ’« é‡‘æ˜Ÿè½¨é“', distFromSunWanKm: 10820 },
        { name: 'ğŸŒ™ æœˆçƒè½¨é“', distFromSunWanKm: 14960 - 38.4, hasBody: true, bodyColor: 0xcccccc, bodyR: 0.4 },
    ];

    // è·å¤ªé˜³ä¸‡km â†’ Xåæ ‡ï¼ˆè´Ÿæ–¹å‘ï¼‰
    function sunDistToX(distFromSunWanKm) {
        return -(distFromSunWanKm / 14960) * SCENE_LENGTH;
    }

    // ---- Renderer ----
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 2000);
    // åˆå§‹ç›¸æœºï¼šçœ‹å¤ªé˜³ï¼Œç¨å¾®åä¸Šåå
    camera.position.set(0, 20, 80);

    // ---- OrbitControlsï¼šå·¦é”®å¹³ç§»ï¼Œå³é”®æ—‹è½¬ï¼Œè‡ªç”±ç§»åŠ¨ ----
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.enablePan = true;
    controls.minDistance = 2;
    controls.maxDistance = 600;
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.rotateSpeed = 0.5;
    controls.panSpeed = 2.0;
    // å·¦é”®å¹³ç§»ï¼Œå³é”®æ—‹è½¬ï¼ˆé»˜è®¤æ˜¯åçš„ï¼Œæ”¹è¿‡æ¥æ›´ç›´è§‚ï¼‰
    controls.mouseButtons = {
        LEFT: THREE.MOUSE.PAN,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.ROTATE
    };
    // è§¦æ‘¸ï¼šå•æŒ‡å¹³ç§»ï¼ŒåŒæŒ‡ç¼©æ”¾+æ—‹è½¬
    controls.touches = {
        ONE: THREE.TOUCH.PAN,
        TWO: THREE.TOUCH.DOLLY_ROTATE
    };
    // å®½æ¾èŒƒå›´ï¼Œé˜²æ­¢é£å¤ªè¿œ
    controls.addEventListener('change', () => {
        controls.target.x = Math.max(-SCENE_LENGTH - 80, Math.min(80, controls.target.x));
        controls.target.y = Math.max(-100, Math.min(100, controls.target.y));
        controls.target.z = Math.max(-100, Math.min(100, controls.target.z));
    });

    // ç¯å¢ƒå…‰
    scene.add(new THREE.AmbientLight(0x334466, 0.3));

    // ============ å¤ªé˜³ï¼ˆåŸç‚¹ï¼‰ ============
    const sunGeo = new THREE.SphereGeometry(SUN_R, 64, 64);
    const sunMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `
            varying vec3 vNormal; varying vec2 vUv;
            void main() {
                vNormal = normalize(normalMatrix * normal); vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time; varying vec3 vNormal; varying vec2 vUv;
            float noise(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
            float fbm(vec2 p) {
                float v = 0.0, a = 0.5;
                for (int i = 0; i < 5; i++) { v += a * noise(p); p *= 2.0; a *= 0.5; }
                return v;
            }
            void main() {
                float n = fbm(vUv * 10.0 + time * 0.1);
                float n2 = fbm(vUv * 20.0 - time * 0.15);
                vec3 c1 = vec3(1.0, 0.95, 0.5), c2 = vec3(1.0, 0.7, 0.2), c3 = vec3(1.0, 0.5, 0.1);
                vec3 color = mix(mix(c1, c2, n), c3, n2 * 0.3);
                color += vec3(1.0, 0.6, 0.2) * pow(1.0 - dot(vNormal, vec3(0,0,1)), 2.0) * 0.5;
                gl_FragColor = vec4(color, 1.0);
            }
        `
    });
    const sunMesh = new THREE.Mesh(sunGeo, sunMat);
    sunMesh.position.set(0, 0, 0);
    scene.add(sunMesh);

    // å¤ªé˜³å…‰æ™• - å†…å±‚
    const coronaMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `varying vec3 vN; void main(){ vN=normalize(normalMatrix*normal); gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `uniform float time; varying vec3 vN; void main(){ float i=pow(0.6-dot(vN,vec3(0,0,1)),2.0); gl_FragColor=vec4(vec3(1,.7,.2)*i*(sin(time*2.)*.1+.9), i*.6); }`,
        transparent: true, blending: THREE.AdditiveBlending, side: THREE.BackSide
    });
    sunMesh.add(new THREE.Mesh(new THREE.SphereGeometry(SUN_R * 1.25, 32, 32), coronaMat));

    // å¤ªé˜³å…‰æ™• - å¤–å±‚
    const outerGlowMat = new THREE.ShaderMaterial({
        vertexShader: `varying vec3 vN; void main(){ vN=normalize(normalMatrix*normal); gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `varying vec3 vN; void main(){ float i=pow(0.4-dot(vN,vec3(0,0,1)),3.0); gl_FragColor=vec4(vec3(1,.5,.1)*i, i*.3); }`,
        transparent: true, blending: THREE.AdditiveBlending, side: THREE.BackSide
    });
    sunMesh.add(new THREE.Mesh(new THREE.SphereGeometry(SUN_R * 1.75, 32, 32), outerGlowMat));

    // å¤ªé˜³ç‚¹å…‰æº
    sunMesh.add(new THREE.PointLight(0xffdd88, 2, 800));

    // ============ åœ°çƒï¼ˆåœ¨è´ŸXæ–¹å‘æœ€è¿œå¤„ï¼‰ ============
    const EARTH_X = -SCENE_LENGTH; // x = -300
    const earthGeo = new THREE.SphereGeometry(EARTH_R, 64, 64);
    const textureLoader = new THREE.TextureLoader();
    const earthDayMap = textureLoader.load('textures/earth_daymap.jpg');
    const earthMat = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            dayTexture: { value: earthDayMap },
            sunDirection: { value: new THREE.Vector3(1, 0, 0) }
        },
        vertexShader: `
            uniform vec3 sunDirection;
            varying vec3 vNormal, vViewDir, vSunDir; varying vec2 vUv;
            void main() {
                vNormal = normalize(normalMatrix * normal); vUv = uv;
                vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
                vViewDir = normalize(-mvPos.xyz);
                vSunDir = normalize(mat3(viewMatrix) * sunDirection);
                gl_Position = projectionMatrix * mvPos;
            }
        `,
        fragmentShader: `
            uniform sampler2D dayTexture;
            varying vec3 vNormal, vViewDir, vSunDir; varying vec2 vUv;
            void main() {
                vec3 sc = texture2D(dayTexture, vUv).rgb * 1.15;
                sc *= max(dot(vNormal, vSunDir), 0.0) * 0.55 + 0.45;
                float f = pow(1.0 - max(dot(vNormal, vViewDir), 0.0), 4.0);
                gl_FragColor = vec4(mix(sc, vec3(0.3, 0.6, 1.0), f * 0.15), 1.0);
            }
        `
    });
    const earthMesh = new THREE.Mesh(earthGeo, earthMat);
    earthMesh.position.set(EARTH_X, 0, 0);
    scene.add(earthMesh);

    // åœ°çƒäº‘å±‚
    const cloudMat = new THREE.MeshPhongMaterial({
        map: textureLoader.load('textures/earth_clouds.jpg'),
        transparent: true, opacity: 0.2, depthWrite: false, side: THREE.DoubleSide
    });
    const cloudMesh = new THREE.Mesh(new THREE.SphereGeometry(EARTH_R * 1.015, 32, 32), cloudMat);
    earthMesh.add(cloudMesh);

    // åœ°çƒå¤§æ°”å±‚å…‰æ™•
    const atmoMat = new THREE.ShaderMaterial({
        vertexShader: `varying vec3 vN; void main(){ vN=normalize(normalMatrix*normal); gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `varying vec3 vN; void main(){ float i=pow(0.55-dot(vN,vec3(0,0,1)),3.0); gl_FragColor=vec4(vec3(.3,.6,1.), i*.4); }`,
        transparent: true, blending: THREE.AdditiveBlending, side: THREE.BackSide, depthWrite: false
    });
    earthMesh.add(new THREE.Mesh(new THREE.SphereGeometry(EARTH_R * 1.1, 32, 32), atmoMat));

    // ============ ç²—è¿çº¿ï¼šå¤ªé˜³ â†’ æ°´æ˜Ÿ â†’ é‡‘æ˜Ÿ â†’ æœˆçƒ â†’ åœ°çƒ ============
    // ç”¨ CylinderGeometry åšç²—ç®¡çº¿ï¼Œæ²¿Xè½´ä»å¤ªé˜³åˆ°åœ°çƒ
    const TUBE_RADIUS = 0.5;
    const tubeLength = SCENE_LENGTH - SUN_R - EARTH_R; // å»æ‰ä¸¤ç«¯å¤©ä½“åŠå¾„
    const tubeGeo = new THREE.CylinderGeometry(TUBE_RADIUS, TUBE_RADIUS, tubeLength, 16, 1, true);
    const tubeMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            varying vec2 vUv;
            void main() {
                // æ²¿ç®¡çº¿æ–¹å‘çš„æ¸å˜ï¼šå¤ªé˜³ç«¯æš–è‰² â†’ åœ°çƒç«¯å†·è‰²
                vec3 sunColor = vec3(1.0, 0.6, 0.15);
                vec3 earthColor = vec3(0.3, 0.5, 1.0);
                vec3 color = mix(sunColor, earthColor, vUv.y);
                // è„‰å†²æµåŠ¨æ•ˆæœ
                float pulse = sin(vUv.y * 30.0 - time * 2.0) * 0.15 + 0.85;
                // è¾¹ç¼˜å‘å…‰
                float edge = 1.0 - abs(vUv.x - 0.5) * 2.0;
                float glow = pow(edge, 0.5);
                float alpha = glow * pulse * 0.6;
                gl_FragColor = vec4(color * (1.0 + pulse * 0.3), alpha);
            }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
    });
    const tubeMesh = new THREE.Mesh(tubeGeo, tubeMat);
    // CylinderGeometry é»˜è®¤æ²¿Yè½´ï¼Œæ—‹è½¬åˆ°æ²¿Xè½´ï¼ˆè´Ÿæ–¹å‘ï¼‰
    tubeMesh.rotation.z = Math.PI / 2;
    // æ”¾ç½®åœ¨å¤ªé˜³è¡¨é¢åˆ°åœ°çƒè¡¨é¢ä¹‹é—´çš„ä¸­ç‚¹
    const tubeCenter = -(SUN_R + tubeLength / 2);
    tubeMesh.position.set(tubeCenter, 0, 0);
    scene.add(tubeMesh);

    // å¤–å±‚å…‰æ™•ç®¡ï¼ˆæ›´ç²—ã€æ›´é€æ˜ï¼Œè¥é€ å‘å…‰æ„Ÿï¼‰
    const glowTubeGeo = new THREE.CylinderGeometry(TUBE_RADIUS * 3, TUBE_RADIUS * 3, tubeLength, 16, 1, true);
    const glowTubeMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            varying vec2 vUv;
            void main() {
                vec3 sunColor = vec3(1.0, 0.5, 0.1);
                vec3 earthColor = vec3(0.2, 0.4, 1.0);
                vec3 color = mix(sunColor, earthColor, vUv.y);
                float edge = 1.0 - abs(vUv.x - 0.5) * 2.0;
                float glow = pow(edge, 3.0);
                float pulse = sin(vUv.y * 20.0 - time * 1.5) * 0.2 + 0.8;
                gl_FragColor = vec4(color, glow * 0.15 * pulse);
            }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
    });
    const glowTubeMesh = new THREE.Mesh(glowTubeGeo, glowTubeMat);
    glowTubeMesh.rotation.z = Math.PI / 2;
    glowTubeMesh.position.set(tubeCenter, 0, 0);
    scene.add(glowTubeMesh);

    // æ²¿ç®¡çº¿çš„æµåŠ¨ç²’å­
    const beamParticleCount = 800;
    const beamPositions = new Float32Array(beamParticleCount * 3);
    const beamSizes = new Float32Array(beamParticleCount);
    const beamAlphas = new Float32Array(beamParticleCount);
    for (let i = 0; i < beamParticleCount; i++) {
        const t = i / beamParticleCount;
        beamPositions[i * 3] = -SUN_R - t * tubeLength;
        const angle = Math.random() * Math.PI * 2;
        const r = Math.random() * TUBE_RADIUS * 0.8;
        beamPositions[i * 3 + 1] = Math.cos(angle) * r;
        beamPositions[i * 3 + 2] = Math.sin(angle) * r;
        beamSizes[i] = Math.random() * 2.0 + 0.8;
        beamAlphas[i] = Math.random() * 0.6 + 0.3;
    }
    const beamGeo = new THREE.BufferGeometry();
    beamGeo.setAttribute('position', new THREE.BufferAttribute(beamPositions, 3));
    beamGeo.setAttribute('size', new THREE.BufferAttribute(beamSizes, 1));
    beamGeo.setAttribute('alpha', new THREE.BufferAttribute(beamAlphas, 1));
    const beamMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `
            attribute float size; attribute float alpha;
            varying float vAlpha; varying float vT; uniform float time;
            void main() {
                // æ ¹æ®Xä½ç½®è®¡ç®—0-1çš„æ’å€¼
                vT = clamp(-position.x / 300.0, 0.0, 1.0);
                vAlpha = alpha * (sin(time * 3.0 + position.x * 0.05) * 0.3 + 0.7);
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (200.0 / -mv.z);
                gl_Position = projectionMatrix * mv;
            }
        `,
        fragmentShader: `
            varying float vAlpha; varying float vT;
            void main() {
                float d = length(gl_PointCoord - 0.5);
                float a = 1.0 - smoothstep(0.0, 0.5, d);
                vec3 sunColor = vec3(1.0, 0.6, 0.2);
                vec3 earthColor = vec3(0.3, 0.5, 1.0);
                vec3 color = mix(sunColor, earthColor, vT);
                gl_FragColor = vec4(color, a * vAlpha * 0.4);
            }
        `,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });
    scene.add(new THREE.Points(beamGeo, beamMat));

    // ============ é‡Œç¨‹ç¢‘æ ‡è®° ============
    function makeTextSprite(text, fontSize, color, maxWidth) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = maxWidth || 512;
        canvas.height = 128;
        ctx.font = `bold ${fontSize}px "Noto Sans SC", sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = color;
        ctx.fillText(text, canvas.width / 2, 64);
        const tex = new THREE.CanvasTexture(canvas);
        tex.minFilter = THREE.LinearFilter;
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
        const sprite = new THREE.Sprite(mat);
        return sprite;
    }

    // å¤ªé˜³æ ‡ç­¾ï¼ˆåŸç‚¹ä¸‹æ–¹ï¼‰
    const sunLabel = makeTextSprite('â˜€ï¸ å¤ªé˜³', 64, 'rgba(255,210,80,1)');
    sunLabel.position.set(0, -SUN_R - 6, 0);
    sunLabel.scale.set(14, 3.5, 1);
    scene.add(sunLabel);

    // åœ°çƒæ ‡ç­¾
    const earthLabel = makeTextSprite('ğŸŒ åœ°çƒ', 64, 'rgba(100,180,255,1)');
    earthLabel.position.set(EARTH_X, -EARTH_R - 3, 0);
    earthLabel.scale.set(12, 3, 1);
    scene.add(earthLabel);

    // åœ°çƒè·ç¦»æ ‡ç­¾
    const earthDistLabel = makeTextSprite('è·å¤ªé˜³ 1.496 äº¿å…¬é‡Œ', 40, 'rgba(100,180,255,0.6)');
    earthDistLabel.position.set(EARTH_X, -EARTH_R - 6.5, 0);
    earthDistLabel.scale.set(16, 4, 1);
    scene.add(earthDistLabel);

    // é‡Œç¨‹ç¢‘æ ‡è®°
    MILESTONES.forEach(m => {
        const x = sunDistToX(m.distFromSunWanKm);

        // è½¨é“ç¯
        const ringGeo = new THREE.RingGeometry(4, 4.3, 64);
        const ringMat = new THREE.MeshBasicMaterial({
            color: 0x4488ff, transparent: true, opacity: 0.2,
            side: THREE.DoubleSide, depthWrite: false
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.set(x, 0, 0);
        ring.rotation.y = Math.PI / 2;
        scene.add(ring);

        // ç«–çº¿æ ‡è®°
        const lineGeo = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(x, -5, 0),
            new THREE.Vector3(x, 5, 0)
        ]);
        const lineMat = new THREE.LineBasicMaterial({
            color: 0x4488ff, transparent: true, opacity: 0.25
        });
        scene.add(new THREE.Line(lineGeo, lineMat));

        // åç§°æ ‡ç­¾
        const nameSprite = makeTextSprite(m.name, 48, 'rgba(100,180,255,0.9)');
        nameSprite.position.set(x, 6.5, 0);
        nameSprite.scale.set(14, 3.5, 1);
        scene.add(nameSprite);

        // è·ç¦»æ ‡ç­¾ï¼ˆè·å¤ªé˜³ï¼‰
        const distText = m.distFromSunWanKm < 100
            ? `è·å¤ªé˜³ ${m.distFromSunWanKm}ä¸‡å…¬é‡Œ`
            : `è·å¤ªé˜³ ${(m.distFromSunWanKm / 10000).toFixed(2)}äº¿å…¬é‡Œ`;
        const distSprite = makeTextSprite(distText, 32, 'rgba(255,255,255,0.35)');
        distSprite.position.set(x, -6.5, 0);
        distSprite.scale.set(14, 3.5, 1);
        scene.add(distSprite);

        // å¤©ä½“ï¼ˆæœˆçƒï¼‰
        if (m.hasBody) {
            const bodyGeo = new THREE.SphereGeometry(m.bodyR, 32, 32);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: m.bodyColor, roughness: 0.8, metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.set(x, 0, 0);
            scene.add(body);
        }
    });

    // ============ æ˜Ÿç©ºç²’å­ ============
    const starCount = 3000;
    const sPos = new Float32Array(starCount * 3);
    const sCol = new Float32Array(starCount * 3);
    const sSiz = new Float32Array(starCount);
    for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        const r = 400 + Math.random() * 500;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        // æ˜Ÿç©ºä»¥åœºæ™¯ä¸­å¿ƒï¼ˆ-150é™„è¿‘ï¼‰ä¸ºä¸­å¿ƒåˆ†å¸ƒ
        sPos[i3] = -150 + r * Math.sin(phi) * Math.cos(theta);
        sPos[i3+1] = r * Math.sin(phi) * Math.sin(theta);
        sPos[i3+2] = r * Math.cos(phi);
        const c = Math.random();
        if (c < 0.6) { sCol[i3]=1; sCol[i3+1]=1; sCol[i3+2]=1; }
        else if (c < 0.8) { sCol[i3]=0.7; sCol[i3+1]=0.8; sCol[i3+2]=1; }
        else { sCol[i3]=1; sCol[i3+1]=0.95; sCol[i3+2]=0.8; }
        sSiz[i] = Math.random() * 2 + 0.5;
    }
    const starGeo = new THREE.BufferGeometry();
    starGeo.setAttribute('position', new THREE.BufferAttribute(sPos, 3));
    starGeo.setAttribute('color', new THREE.BufferAttribute(sCol, 3));
    starGeo.setAttribute('size', new THREE.BufferAttribute(sSiz, 1));
    const starMat = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `
            attribute float size; attribute vec3 color;
            varying vec3 vColor; uniform float time;
            void main() {
                vColor = color;
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (300.0 / -mv.z) * (sin(time*2.0+position.x*.01)*.3+.7);
                gl_Position = projectionMatrix * mv;
            }
        `,
        fragmentShader: `
            varying vec3 vColor;
            void main() {
                float d = length(gl_PointCoord - .5);
                float a = 1.0 - smoothstep(0.0, 0.5, d);
                gl_FragColor = vec4(vColor, (a + exp(-d*3.)*.5) * .9);
            }
        `,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });
    scene.add(new THREE.Points(starGeo, starMat));

    // ============ HTML é‡Œç¨‹ç¢‘é¢æ¿ ============
    const milestonePanelEl = document.getElementById('milestonePanel');
    const allMilestones = [
        { name: 'â˜€ï¸ å¤ªé˜³', distFromSunWanKm: 0 },
        ...MILESTONES,
        { name: 'ğŸŒ åœ°çƒ', distFromSunWanKm: 14960 }
    ];
    allMilestones.forEach((m, idx) => {
        const div = document.createElement('div');
        div.className = 'milestone-item' + (idx === 0 ? ' active' : '');
        div.dataset.dist = m.distFromSunWanKm;
        const distText = m.distFromSunWanKm === 0 ? 'ä¸­å¿ƒ'
            : m.distFromSunWanKm < 100 ? `è·å¤ªé˜³ ${m.distFromSunWanKm}ä¸‡km`
            : `è·å¤ªé˜³ ${(m.distFromSunWanKm * 10000).toLocaleString('zh-CN')} km`;
        div.innerHTML = `<div class="milestone-name">${m.name}</div><div class="milestone-dist">${distText}</div>`;
        div.style.pointerEvents = 'auto';
        div.style.cursor = 'pointer';
        div.addEventListener('click', () => {
            const targetX = sunDistToX(m.distFromSunWanKm);
            animateCameraTo(targetX);
        });
        milestonePanelEl.appendChild(div);
    });

    // ============ ç›¸æœºåŠ¨ç”»ï¼ˆç‚¹å‡»é‡Œç¨‹ç¢‘è·³è½¬ï¼‰ ============
    let cameraAnimating = false;
    let cameraAnimStart = null;
    let cameraAnimFrom = null;
    let cameraAnimTo = null;
    const CAMERA_ANIM_DURATION = 1500;

    function animateCameraTo(targetX) {
        cameraAnimating = true;
        cameraAnimStart = performance.now();
        cameraAnimFrom = { x: controls.target.x, camX: camera.position.x };
        const offsetX = camera.position.x - controls.target.x;
        cameraAnimTo = { x: targetX, camX: targetX + offsetX };
    }

    function updateCameraAnim(now) {
        if (!cameraAnimating) return;
        const elapsed = now - cameraAnimStart;
        let t = Math.min(1, elapsed / CAMERA_ANIM_DURATION);
        t = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        controls.target.x = cameraAnimFrom.x + (cameraAnimTo.x - cameraAnimFrom.x) * t;
        camera.position.x = cameraAnimFrom.camX + (cameraAnimTo.camX - cameraAnimFrom.camX) * t;
        if (elapsed >= CAMERA_ANIM_DURATION) cameraAnimating = false;
    }

    // ============ è·ç¦»è®¡æ•°å™¨æ›´æ–° ============
    const distValueEl = document.getElementById('distValue');
    const distUnitEl = document.getElementById('distUnit');
    const zoomBarFill = document.getElementById('zoomBarFill');

    function updateDistanceCounter() {
        // ç›¸æœºçœ‹å‘çš„ä½ç½®ï¼ˆcontrols.target.xï¼‰ï¼Œå¤ªé˜³åœ¨0ï¼Œåœ°çƒåœ¨-300
        // è·å¤ªé˜³çš„è·ç¦» = |target.x| æ˜ å°„åˆ°çœŸå®è·ç¦»
        const targetX = Math.abs(Math.min(0, Math.max(-SCENE_LENGTH, controls.target.x)));
        const realDistKm = (targetX / SCENE_LENGTH) * REAL_DISTANCE;

        // æ ¼å¼åŒ–
        if (realDistKm < 10000) {
            distValueEl.textContent = Math.round(realDistKm).toLocaleString('zh-CN');
            distUnitEl.textContent = 'åƒç±³';
        } else if (realDistKm < 1000000) {
            distValueEl.textContent = (realDistKm / 10000).toFixed(1);
            distUnitEl.textContent = 'ä¸‡åƒç±³';
        } else if (realDistKm < 100000000) {
            distValueEl.textContent = Math.round(realDistKm).toLocaleString('zh-CN');
            distUnitEl.textContent = 'åƒç±³';
        } else {
            distValueEl.textContent = (realDistKm / 100000000).toFixed(4);
            distUnitEl.textContent = 'äº¿åƒç±³';
        }

        // æ›´æ–°ç¼©æ”¾è¿›åº¦æ¡ï¼ˆä»å¤ªé˜³åˆ°åœ°çƒï¼‰
        const progress = (targetX / SCENE_LENGTH) * 100;
        zoomBarFill.style.width = progress + '%';

        // æ›´æ–°é‡Œç¨‹ç¢‘é¢æ¿é«˜äº®
        const currentDistWanKm = (targetX / SCENE_LENGTH) * 14960;
        const items = milestonePanelEl.querySelectorAll('.milestone-item');
        items.forEach(item => {
            const d = parseFloat(item.dataset.dist);
            item.classList.remove('active', 'passed');
            if (Math.abs(currentDistWanKm - d) < (d < 100 ? 10 : 600)) {
                item.classList.add('active');
            } else if (currentDistWanKm > d) {
                item.classList.add('passed');
            }
        });
    }

    // ============ å°ºå¯¸è‡ªé€‚åº” ============
    function resize() {
        const w = window.innerWidth, h = window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
    }
    resize();
    window.addEventListener('resize', resize);

    // ============ è§¦æ‘¸è®¾å¤‡æç¤º ============
    if ('ontouchstart' in window) {
        document.getElementById('bottomHint').textContent = 'å•æŒ‡æ‹–åŠ¨å¹³ç§» Â· åŒæŒ‡ç¼©æ”¾æ—‹è½¬ Â· è‡ªç”±æ¢ç´¢å¤ªé˜³åˆ°åœ°çƒ';
    }

    // ============ åŠ¨ç”»å¾ªç¯ ============
    function animate(ts) {
        requestAnimationFrame(animate);
        const t = ts * 0.001;

        sunMat.uniforms.time.value = t;
        coronaMat.uniforms.time.value = t;
        starMat.uniforms.time.value = t;
        beamMat.uniforms.time.value = t;
        tubeMat.uniforms.time.value = t;
        glowTubeMat.uniforms.time.value = t;

        earthMesh.rotation.y += 0.002;
        cloudMesh.rotation.y -= 0.001;
        sunMesh.rotation.y += 0.0005;

        updateCameraAnim(ts);
        controls.update();
        updateDistanceCounter();
        renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);
})();
</script>
</body>
</html>
