<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é™¨çŸ³æ’å‡»åœ°çƒ - æŸ³æ™ºå¤©çš„å®‡å®™è¯¾å ‚</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700;900&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Noto Sans SC', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            min-height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
            pointer-events: none;
        }

        .header > * { pointer-events: auto; }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, #ff6b35, #ff4500);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.5);
        }

        .logo-text h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            color: #ff6b35;
            text-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        .logo-text p {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
        }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            color: rgba(255,255,255,0.7);
            text-decoration: none;
            font-size: 0.85rem;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        .controls {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 30px;
            backdrop-filter: blur(10px);
        }

        .control-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: linear-gradient(145deg, #ff6b35, #ff4500);
            border: none;
            border-radius: 20px;
            color: #fff;
            font-family: 'Noto Sans SC', sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 69, 0, 0.4);
        }

        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 25px rgba(255, 69, 0, 0.6);
        }

        .control-btn:disabled {
            background: #444;
            cursor: not-allowed;
            box-shadow: none;
        }

        .control-btn.secondary {
            background: rgba(255,255,255,0.1);
            box-shadow: none;
        }

        .control-btn.secondary:hover {
            background: rgba(255,255,255,0.2);
            box-shadow: none;
        }

        .info-panel {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 320px;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
            z-index: 100;
            background: rgba(0,0,0,0.75);
            border: 1px solid rgba(255,107,53,0.3);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .info-panel h2 {
            font-size: 1.2rem;
            color: #ff6b35;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-panel p {
            font-size: 0.9rem;
            line-height: 1.7;
            color: rgba(255,255,255,0.85);
            margin-bottom: 12px;
        }

        .info-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .info-section h3 {
            font-size: 1rem;
            color: #ffd93d;
            margin-bottom: 8px;
        }

        .fact-list {
            list-style: none;
        }

        .fact-list li {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.75);
            padding: 6px 0;
            padding-left: 20px;
            position: relative;
        }

        .fact-list li::before {
            content: 'â˜„ï¸';
            position: absolute;
            left: 0;
            font-size: 0.8rem;
        }

        .status-display {
            position: fixed;
            left: 20px;
            bottom: 100px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: rgba(255,255,255,0.8);
            margin: 4px 0;
        }

        .status-value {
            color: #ff6b35;
            font-weight: 700;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a0a00 0%, #000 100%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-icon {
            font-size: 4rem;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .loading-text {
            margin-top: 20px;
            font-size: 1.2rem;
            color: #ff6b35;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .impact-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }

        .impact-flash.active {
            opacity: 1;
        }

        .home-btn {
            position: fixed;
            left: 20px;
            bottom: 20px;
            z-index: 100;
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 20px;
            color: rgba(255,255,255,0.6);
            text-decoration: none;
            font-size: 0.85rem;
            backdrop-filter: blur(8px);
            transition: all 0.3s;
        }

        .home-btn:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        @media (max-width: 768px) {
            .info-panel {
                display: none;
            }
            .controls {
                flex-wrap: wrap;
                justify-content: center;
                width: 90%;
            }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-icon">â˜„ï¸</div>
        <div class="loading-text">æ­£åœ¨åŠ è½½é™¨çŸ³æ’å‡»æ¨¡æ‹Ÿ...</div>
    </div>

    <div class="impact-flash" id="impactFlash"></div>

    <div id="canvas-container"></div>

    <div class="header">
        <div class="logo">
            <div class="logo-icon">â˜„ï¸</div>
            <div class="logo-text">
                <h1>ASTEROID IMPACT</h1>
                <p>é™¨çŸ³æ’å‡»åœ°çƒ</p>
            </div>
        </div>
        <a href="solar-system.html" class="back-btn">
            <span>â†</span>
            <span>è¿”å›å¤ªé˜³ç³»</span>
        </a>
    </div>

    <div class="info-panel">
        <h2>â˜„ï¸ ä»€ä¹ˆæ˜¯é™¨çŸ³ï¼Ÿ</h2>
        <p>é™¨çŸ³æ˜¯æ¥è‡ªå¤ªç©ºçš„å²©çŸ³æˆ–é‡‘å±ç¢ç‰‡ï¼Œå½“å®ƒä»¬ç©¿è¿‡åœ°çƒå¤§æ°”å±‚å¹¶è½åˆ°åœ°é¢æ—¶ï¼Œå°±è¢«ç§°ä¸ºé™¨çŸ³ã€‚</p>
        <p>åœ¨å¤ªç©ºä¸­é£è¡Œæ—¶ï¼Œå®ƒä»¬å«åš<strong style="color:#ffd93d">æµæ˜Ÿä½“</strong>ï¼›è¿›å…¥å¤§æ°”å±‚ç‡ƒçƒ§å‘å…‰æ—¶å«åš<strong style="color:#ffd93d">æµæ˜Ÿ</strong>ï¼›è½åˆ°åœ°é¢åæ‰å«<strong style="color:#ffd93d">é™¨çŸ³</strong>ã€‚</p>

        <div class="info-section">
            <h3>ğŸ”¥ é™¨çŸ³æ’å‡»çš„å¨åŠ›</h3>
            <ul class="fact-list">
                <li>å°é™¨çŸ³ï¼ˆ1ç±³ï¼‰ä¼šåœ¨å¤§æ°”å±‚ä¸­ç‡ƒçƒ§æ®†å°½</li>
                <li>ä¸­ç­‰é™¨çŸ³ï¼ˆ50ç±³ï¼‰èƒ½æ‘§æ¯ä¸€åº§åŸå¸‚</li>
                <li>å¤§é™¨çŸ³ï¼ˆ10å…¬é‡Œï¼‰å¯èƒ½å¯¼è‡´ç‰©ç§ç­ç»</li>
                <li>6500ä¸‡å¹´å‰ï¼Œä¸€é¢—10å…¬é‡Œçš„é™¨çŸ³å¯¼è‡´æé¾™ç­ç»</li>
            </ul>
        </div>

        <div class="info-section">
            <h3>ğŸŒ è‘—åé™¨çŸ³å‘</h3>
            <ul class="fact-list">
                <li>ç¾å›½äºšåˆ©æ¡‘é‚£é™¨çŸ³å‘ï¼šç›´å¾„1.2å…¬é‡Œ</li>
                <li>å¢¨è¥¿å“¥å¸Œå…‹è‹é²ä¼¯å‘ï¼šç›´å¾„180å…¬é‡Œï¼ˆæé¾™ç­ç»ï¼‰</li>
                <li>å—éå¼—é‡Œå¾·å ¡å‘ï¼šç›´å¾„300å…¬é‡Œï¼ˆæœ€å¤§ï¼‰</li>
            </ul>
        </div>

        <div class="info-section">
            <h3>ğŸ’ é™¨çŸ³çš„ç±»å‹</h3>
            <ul class="fact-list">
                <li><strong>çŸ³é™¨çŸ³</strong>ï¼šä¸»è¦ç”±ç¡…é…¸ç›çŸ¿ç‰©ç»„æˆ</li>
                <li><strong>é“é™¨çŸ³</strong>ï¼šä¸»è¦ç”±é“å’Œé•ç»„æˆ</li>
                <li><strong>çŸ³é“é™¨çŸ³</strong>ï¼šå²©çŸ³å’Œé‡‘å±çš„æ··åˆç‰©</li>
            </ul>
        </div>
    </div>

    <div class="status-display" id="statusDisplay">
        <div class="status-item">
            <span>ğŸ“ é™¨çŸ³ç›´å¾„:</span>
            <span class="status-value" id="asteroidSize">500 ç±³</span>
        </div>
        <div class="status-item">
            <span>ğŸš€ æ’å‡»é€Ÿåº¦:</span>
            <span class="status-value" id="impactSpeed">20 km/s</span>
        </div>
        <div class="status-item">
            <span>ğŸ’¥ æ’å‡»çŠ¶æ€:</span>
            <span class="status-value" id="impactStatus">å‡†å¤‡å°±ç»ª</span>
        </div>
    </div>

    <div class="controls">
        <button class="control-btn" id="launchBtn" onclick="launchAsteroid()">
            <span>ğŸš€</span>
            <span>å‘å°„é™¨çŸ³</span>
        </button>
        <button class="control-btn secondary" id="resetBtn" onclick="resetScene()">
            <span>ğŸ”„</span>
            <span>é‡ç½®</span>
        </button>
    </div>

    <a href="../index.html" class="home-btn">ğŸ  é¦–é¡µ</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // ============ å…¨å±€å˜é‡ ============
        let scene, camera, renderer, controls;
        let earth, asteroid, atmosphere;
        let particles = [];
        let impactCrater = null;
        let debrisParticles = [];
        let shockwave = null;
        let fireParticles = [];

        let isLaunched = false;
        let hasImpacted = false;
        let asteroidVelocity = new THREE.Vector3();
        let earthRotationEnabled = true;
        let cameraZoomingToCrater = false;
        let impactPointGlobal = null;

        const EARTH_RADIUS = 50;
        const ASTEROID_RADIUS = 10;
        const IMPACT_SPEED = 1.2;

        // ============ åˆå§‹åŒ– ============
        function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000008);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 30, 200);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 80;
            controls.maxDistance = 400;

            // åˆ›å»ºåœºæ™¯å…ƒç´ 
            createStars();
            createEarth();
            createAsteroid();
            createLighting();

            // éšè—åŠ è½½å±å¹•
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
            }, 800);

            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }

        // ============ åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯ ============
        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starPositions = [];

            for (let i = 0; i < 5000; i++) {
                const x = (Math.random() - 0.5) * 4000;
                const y = (Math.random() - 0.5) * 4000;
                const z = (Math.random() - 0.5) * 4000;
                starPositions.push(x, y, z);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));

            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.5,
                sizeAttenuation: true
            });

            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        // ============ åˆ›å»ºåœ°çƒ ============
        function createEarth() {
            const geometry = new THREE.SphereGeometry(EARTH_RADIUS, 128, 128);

            const earthMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    impactPoint: { value: new THREE.Vector3(0, 0, 1) },
                    impactStrength: { value: 0.0 },
                    craterSize: { value: 0.0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;

                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vUv = uv;
                        vPosition = position;
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 impactPoint;
                    uniform float impactStrength;
                    uniform float craterSize;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;

                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                    }

                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);
                        float a = hash(i);
                        float b = hash(i + vec2(1.0, 0.0));
                        float c = hash(i + vec2(0.0, 1.0));
                        float d = hash(i + vec2(1.0, 1.0));
                        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                    }

                    float fbm(vec2 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        for (int i = 0; i < 6; i++) {
                            value += amplitude * noise(p);
                            p *= 2.0;
                            amplitude *= 0.5;
                        }
                        return value;
                    }

                    void main() {
                        vec2 uv = vUv;

                        // å¤§é™†
                        float continent = fbm(uv * 8.0 + vec2(1.5, 0.5));
                        continent += fbm(uv * 16.0) * 0.3;
                        float landMask = smoothstep(0.45, 0.55, continent);

                        // æµ·æ´‹
                        vec3 deepOcean = vec3(0.02, 0.08, 0.25);
                        vec3 shallowOcean = vec3(0.1, 0.3, 0.55);
                        vec3 oceanColor = mix(deepOcean, shallowOcean, fbm(uv * 20.0) * 0.5 + 0.3);

                        // é™†åœ°
                        vec3 forest = vec3(0.1, 0.35, 0.15);
                        vec3 plains = vec3(0.25, 0.45, 0.2);
                        vec3 desert = vec3(0.65, 0.55, 0.35);

                        float terrainNoise = fbm(uv * 12.0 + 3.0);
                        vec3 landColor = mix(forest, plains, terrainNoise);

                        float equator = 1.0 - abs(uv.y - 0.5) * 2.0;
                        float desertMask = smoothstep(0.5, 0.7, terrainNoise) * equator;
                        landColor = mix(landColor, desert, desertMask * 0.7);

                        // æåœ°
                        float polar = smoothstep(0.15, 0.0, uv.y) + smoothstep(0.85, 1.0, uv.y);
                        vec3 ice = vec3(0.9, 0.95, 1.0);

                        vec3 surfaceColor = mix(oceanColor, landColor, landMask);
                        surfaceColor = mix(surfaceColor, ice, polar * 0.8);

                        // äº‘å±‚
                        float clouds = fbm(uv * 6.0 + time * 0.008);
                        clouds = smoothstep(0.4, 0.7, clouds);
                        surfaceColor = mix(surfaceColor, vec3(1.0), clouds * 0.35);

                        // é™¨çŸ³å‘æ•ˆæœ - æœˆçƒè¡¨é¢å‘æ´¼è´¨æ„Ÿï¼ˆé™æ€ï¼‰
                        vec3 normalizedPos = normalize(vPosition);
                        float distToImpact = distance(normalizedPos, impactPoint);

                        if (craterSize > 0.0 && distToImpact < craterSize) {
                            float ratio = distToImpact / craterSize;
                            float craterDepth = 1.0 - ratio;
                            craterDepth = pow(craterDepth, 0.5);

                            // æœˆçƒå‘æ´¼çš„ç°è‰²è°ƒ
                            vec3 craterFloor = vec3(0.18, 0.16, 0.14);  // å‘åº•æ·±ç°
                            vec3 craterWall = vec3(0.35, 0.32, 0.28);   // å‘å£ä¸­ç°
                            vec3 craterRim = vec3(0.55, 0.50, 0.45);    // å‘æ²¿æµ…ç°

                            // å‘åº•ç”¨å™ªå£°åšå‡¹å‡¸ä¸å¹³çš„çº¹ç†ï¼ˆé™æ€ï¼Œä¸éšæ—¶é—´å˜åŒ–ï¼‰
                            float bumpNoise = fbm(normalizedPos.xy * 60.0 + normalizedPos.yz * 40.0);
                            float smallBump = noise(normalizedPos.xy * 120.0 + normalizedPos.zz * 80.0);

                            // åˆ†å±‚ï¼šä¸­å¿ƒå¹³å¦å‘åº• â†’ å‘å£ â†’ éš†èµ·çš„è¾¹ç¼˜
                            float floorMask = smoothstep(0.0, 0.35, ratio);
                            float wallMask = smoothstep(0.35, 0.7, ratio);
                            float rimMask = smoothstep(0.7, 0.92, ratio);

                            vec3 craterColor = mix(craterFloor, craterWall, floorMask);
                            craterColor = mix(craterColor, craterRim, rimMask);

                            // å‘åº•æ·»åŠ é™æ€å‡¹å‡¸çº¹ç†ï¼ˆåƒæœˆçƒè¡¨é¢å°å‘ï¼‰
                            float microCraters = smoothstep(0.55, 0.65, bumpNoise) * (1.0 - ratio);
                            craterColor = mix(craterColor, craterFloor * 0.6, microCraters * 0.5);

                            // å‘å£ä¸Šçš„ç»†çº¹ç†
                            float wallTexture = smallBump * 0.15 * (1.0 - abs(ratio - 0.5) * 2.0);
                            craterColor += vec3(wallTexture);

                            // è¾¹ç¼˜éš†èµ·é«˜äº®ï¼ˆé˜³å…‰ç…§åˆ°éš†èµ·éƒ¨åˆ†ï¼‰
                            float rimHighlight = smoothstep(0.82, 0.92, ratio) * smoothstep(1.0, 0.92, ratio);
                            craterColor += vec3(0.2, 0.18, 0.15) * rimHighlight;

                            surfaceColor = mix(surfaceColor, craterColor, craterDepth);
                        }

                        // å¤§æ°”æ•£å°„
                        float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
                        vec3 atmosphereCol = vec3(0.3, 0.6, 1.0);
                        surfaceColor = mix(surfaceColor, atmosphereCol, fresnel * 0.3);

                        // å…‰ç…§
                        vec3 lightDir = normalize(vec3(-1.0, 0.3, 0.5));
                        float diff = max(dot(vNormal, lightDir), 0.0);
                        surfaceColor *= (diff * 0.6 + 0.4);

                        gl_FragColor = vec4(surfaceColor, 1.0);
                    }
                `
            });

            earth = new THREE.Mesh(geometry, earthMaterial);
            scene.add(earth);

            // å¤§æ°”å±‚
            const atmosphereGeometry = new THREE.SphereGeometry(EARTH_RADIUS * 1.12, 64, 64);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.65 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.5);
                        gl_FragColor = vec4(0.3, 0.6, 1.0, intensity * 0.5);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false
            });

            atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);
        }

        // ============ åˆ›å»ºé™¨çŸ³ ============
        function createAsteroid() {
            // åˆ›å»ºä¸è§„åˆ™çš„é™¨çŸ³å‡ ä½•ä½“
            const geometry = new THREE.IcosahedronGeometry(ASTEROID_RADIUS, 3);

            // è®©é¡¶ç‚¹éšæœºåç§»ï¼Œå½¢æˆå‘å‘æ´¼æ´¼çš„æ•ˆæœ
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);

                const noise = (Math.random() - 0.5) * 0.8;
                const length = Math.sqrt(x*x + y*y + z*z);
                const factor = 1 + noise * 0.3;

                positions.setX(i, x * factor);
                positions.setY(i, y * factor);
                positions.setZ(i, z * factor);
            }
            geometry.computeVertexNormals();

            // é™¨çŸ³æè´¨
            const asteroidMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;

                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;

                    float hash(vec3 p) {
                        return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
                    }

                    float noise(vec3 p) {
                        vec3 i = floor(p);
                        vec3 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);

                        float n = mix(
                            mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),
                                mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                            mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                        return n;
                    }

                    void main() {
                        // åŸºç¡€å²©çŸ³é¢œè‰²
                        vec3 rockDark = vec3(0.15, 0.12, 0.1);
                        vec3 rockLight = vec3(0.4, 0.35, 0.3);
                        vec3 rockRust = vec3(0.5, 0.3, 0.2);

                        float n = noise(vPosition * 2.0);
                        float n2 = noise(vPosition * 5.0);

                        vec3 rockColor = mix(rockDark, rockLight, n);
                        rockColor = mix(rockColor, rockRust, n2 * 0.4);

                        // é™¨çŸ³å‘çº¹ç†
                        float craters = noise(vPosition * 8.0);
                        craters = smoothstep(0.5, 0.7, craters);
                        rockColor = mix(rockColor, rockDark * 0.5, craters * 0.5);

                        // é‡‘å±å…‰æ³½ï¼ˆé“é™¨çŸ³ç‰¹å¾ï¼‰
                        float metallic = noise(vPosition * 3.0 + 10.0);
                        vec3 metalColor = vec3(0.6, 0.55, 0.5);
                        rockColor = mix(rockColor, metalColor, metallic * 0.2);

                        // å…‰ç…§
                        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                        float diff = max(dot(vNormal, lightDir), 0.0);
                        float ambient = 0.3;

                        vec3 finalColor = rockColor * (diff * 0.7 + ambient);

                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });

            asteroid = new THREE.Mesh(geometry, asteroidMaterial);
            // é™¨çŸ³ä»è¿œå¤„å·¦ä¸Šæ–¹é£æ¥ï¼Œé•¿è·ç¦»é£è¡Œåæ’å‡»åœ°çƒæ­£é¢
            // xè´Ÿ(å·¦)è¾ƒå¤§, yæ­£(ä¸Š)è¾ƒå¤§, zè´Ÿ(åæ–¹)ç¡®ä¿æ’å‡»æ­£é¢
            asteroid.position.set(-220, 120, -280);
            scene.add(asteroid);

            // æ·»åŠ é™¨çŸ³å°¾è¿¹ï¼ˆç‡ƒçƒ§æ•ˆæœï¼‰
            createAsteroidTrail();
        }

        // ============ é™¨çŸ³å°¾è¿¹ ============
        let asteroidTrail = null;

        function createAsteroidTrail() {
            const trailGeometry = new THREE.BufferGeometry();
            const trailCount = 500;
            const positions = new Float32Array(trailCount * 3);
            const colors = new Float32Array(trailCount * 3);
            const sizes = new Float32Array(trailCount);

            for (let i = 0; i < trailCount; i++) {
                positions[i * 3] = asteroid.position.x;
                positions[i * 3 + 1] = asteroid.position.y;
                positions[i * 3 + 2] = asteroid.position.z;

                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.5;
                colors[i * 3 + 2] = 0.1;

                sizes[i] = Math.random() * 3 + 1;
            }

            trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            trailGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const trailMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            asteroidTrail = new THREE.Points(trailGeometry, trailMaterial);
            asteroidTrail.visible = false;
            scene.add(asteroidTrail);
        }

        // ============ ç¯å…‰ ============
        function createLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(-100, 50, 100);
            scene.add(sunLight);
        }

        // ============ å‘å°„é™¨çŸ³ ============
        function launchAsteroid() {
            if (isLaunched) return;

            isLaunched = true;
            document.getElementById('launchBtn').disabled = true;
            document.getElementById('impactStatus').textContent = 'æ­£åœ¨æ¥è¿‘...';

            // è®¡ç®—æ’å‡»æ–¹å‘
            const direction = new THREE.Vector3();
            direction.subVectors(earth.position, asteroid.position).normalize();
            asteroidVelocity.copy(direction).multiplyScalar(IMPACT_SPEED);

            // æ˜¾ç¤ºå°¾è¿¹
            asteroidTrail.visible = true;
        }

        // ============ æ’å‡»æ•ˆæœ ============
        function createImpactEffect(impactPoint) {
            // å±å¹•é—ªç™½
            const flash = document.getElementById('impactFlash');
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 200);

            // ç›¸æœºéœ‡åŠ¨
            const originalPos = camera.position.clone();
            let shakeTime = 0;
            const shakeInterval = setInterval(() => {
                shakeTime += 0.05;
                if (shakeTime > 1) {
                    camera.position.copy(originalPos);
                    clearInterval(shakeInterval);
                    return;
                }
                const intensity = (1 - shakeTime) * 5;
                camera.position.x = originalPos.x + (Math.random() - 0.5) * intensity;
                camera.position.y = originalPos.y + (Math.random() - 0.5) * intensity;
                camera.position.z = originalPos.z + (Math.random() - 0.5) * intensity;
            }, 16);

            // åˆ›å»ºçˆ†ç‚¸ç²’å­
            createExplosionParticles(impactPoint);

            // åˆ›å»ºå†²å‡»æ³¢
            createShockwave(impactPoint);

            // æ›´æ–°åœ°çƒæè´¨ï¼ˆæ˜¾ç¤ºé™¨çŸ³å‘ï¼‰
            // æ³¨æ„ï¼šéœ€è¦å°†ä¸–ç•Œåæ ‡è½¬æ¢ä¸ºåœ°çƒæ¨¡å‹ç©ºé—´åæ ‡
            // å› ä¸ºåœ°çƒå¯èƒ½å·²ç»æ—‹è½¬è¿‡ï¼Œéœ€è¦åº”ç”¨é€†æ—‹è½¬
            const impactDir = impactPoint.clone().normalize();
            // åº”ç”¨åœ°çƒæ—‹è½¬çš„é€†å˜æ¢
            const inverseRotation = new THREE.Quaternion().setFromEuler(earth.rotation).invert();
            impactDir.applyQuaternion(inverseRotation);
            earth.material.uniforms.impactPoint.value.copy(impactDir);

            // æ¸è¿›æ˜¾ç¤ºé™¨çŸ³å‘
            let craterGrowth = 0;
            const craterInterval = setInterval(() => {
                craterGrowth += 0.02;
                if (craterGrowth > 0.35) {
                    clearInterval(craterInterval);
                    earth.material.uniforms.impactStrength.value = 0;
                    return;
                }
                earth.material.uniforms.craterSize.value = craterGrowth;
                earth.material.uniforms.impactStrength.value = 0;
            }, 25);

            // éšè—é™¨çŸ³
            asteroid.visible = false;
            asteroidTrail.visible = false;

            // åœæ­¢åœ°çƒè‡ªè½¬
            earthRotationEnabled = false;

            // ä¿å­˜æ’å‡»ç‚¹ç”¨äºç›¸æœºåŠ¨ç”»
            impactPointGlobal = impactPoint.clone();

            // å»¶è¿Ÿåå°†ç›¸æœºæ¨è¿‘åˆ°é™¨çŸ³å‘
            setTimeout(() => {
                zoomToCrater(impactPoint);
            }, 1500);

            document.getElementById('impactStatus').textContent = 'æ’å‡»å®Œæˆï¼';
        }

        // ============ ç›¸æœºæ¨è¿‘é™¨çŸ³å‘ ============
        function zoomToCrater(impactPoint) {
            cameraZoomingToCrater = true;
            controls.enabled = false;

            // è®¡ç®—é™¨çŸ³å‘ä½ç½®ï¼ˆåœ°çƒè¡¨é¢ï¼‰
            const craterNormal = impactPoint.clone().normalize();
            const craterPos = craterNormal.clone().multiplyScalar(EARTH_RADIUS);

            // ç›¸æœºç›®æ ‡ä½ç½®ï¼šä»é™¨çŸ³å‘æ­£ä¸Šæ–¹ï¼ˆæ²¿æ³•çº¿æ–¹å‘ï¼‰å¾€å¤–åç§»
            // åŒæ—¶ç¨å¾®åç§»ä¸€ç‚¹è§’åº¦ï¼Œè®©è§†è§’æ›´è‡ªç„¶
            const cameraDistance = 45;
            const targetCameraPos = craterNormal.clone().multiplyScalar(EARTH_RADIUS + cameraDistance);

            // ç¨å¾®å‘ä¸Šåç§»ä¸€ç‚¹ï¼Œç»™ä¸€ä¸ªä¿¯è§†è§’åº¦
            targetCameraPos.y += 15;

            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const endTarget = craterPos.clone();

            const duration = 2500;
            const startTime = performance.now();

            function animateCamera() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // æ›´å¹³æ»‘çš„ç¼“åŠ¨å‡½æ•°
                const eased = 1 - Math.pow(1 - progress, 4);

                // æ’å€¼ç›¸æœºä½ç½®
                camera.position.lerpVectors(startPos, targetCameraPos, eased);

                // æ’å€¼è§‚å¯Ÿç›®æ ‡
                controls.target.lerpVectors(startTarget, endTarget, eased);

                // æ›´æ–°ç›¸æœºæœå‘
                camera.lookAt(controls.target);

                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                } else {
                    cameraZoomingToCrater = false;
                    controls.enabled = true;
                    controls.minDistance = 20;
                    controls.update();
                    document.getElementById('impactStatus').textContent = 'è§‚å¯Ÿé™¨çŸ³å‘';
                }
            }

            animateCamera();
        }

        // ============ çˆ†ç‚¸ç²’å­ ============
        function createExplosionParticles(center) {
            const particleCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = center.x;
                positions[i * 3 + 1] = center.y;
                positions[i * 3 + 2] = center.z;

                // éšæœºé€Ÿåº¦æ–¹å‘ï¼ˆå¤§éƒ¨åˆ†å‘å¤–ï¼‰
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                vel.add(center.clone().normalize().multiplyScalar(0.5));
                vel.normalize().multiplyScalar(Math.random() * 3 + 1);
                velocities.push(vel);

                // ç«ç„°é¢œè‰²æ¸å˜
                const t = Math.random();
                if (t < 0.3) {
                    colors[i * 3] = 1.0;
                    colors[i * 3 + 1] = 0.9;
                    colors[i * 3 + 2] = 0.5;
                } else if (t < 0.7) {
                    colors[i * 3] = 1.0;
                    colors[i * 3 + 1] = 0.4;
                    colors[i * 3 + 2] = 0.1;
                } else {
                    colors[i * 3] = 0.5;
                    colors[i * 3 + 1] = 0.1;
                    colors[i * 3 + 2] = 0.0;
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const explosion = new THREE.Points(geometry, material);
            explosion.userData.velocities = velocities;
            explosion.userData.life = 1.0;
            scene.add(explosion);
            debrisParticles.push(explosion);
        }

        // ============ å†²å‡»æ³¢ ============
        function createShockwave(center) {
            const geometry = new THREE.RingGeometry(0.1, 1, 64);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });

            shockwave = new THREE.Mesh(geometry, material);
            shockwave.position.copy(center);
            shockwave.lookAt(earth.position);
            shockwave.userData.scale = 1;
            scene.add(shockwave);
        }

        // ============ é‡ç½®åœºæ™¯ ============
        function resetScene() {
            // é‡ç½®é™¨çŸ³ä½ç½®ï¼ˆä¸åˆå§‹ä½ç½®ä¸€è‡´ï¼‰
            asteroid.position.set(-220, 120, -280);
            asteroid.visible = true;
            asteroidTrail.visible = false;

            // é‡ç½®çŠ¶æ€
            isLaunched = false;
            hasImpacted = false;
            asteroidVelocity.set(0, 0, 0);
            earthRotationEnabled = true;
            cameraZoomingToCrater = false;
            impactPointGlobal = null;

            // é‡ç½®åœ°çƒæè´¨
            earth.material.uniforms.impactStrength.value = 0;
            earth.material.uniforms.craterSize.value = 0;

            // æ¸…é™¤çˆ†ç‚¸ç²’å­
            debrisParticles.forEach(p => scene.remove(p));
            debrisParticles = [];

            // æ¸…é™¤å†²å‡»æ³¢
            if (shockwave) {
                scene.remove(shockwave);
                shockwave = null;
            }

            // é‡ç½®ç›¸æœºä½ç½®
            camera.position.set(0, 30, 200);
            controls.target.set(0, 0, 0);
            controls.minDistance = 80;
            controls.enabled = true;

            // é‡ç½®UI
            document.getElementById('launchBtn').disabled = false;
            document.getElementById('impactStatus').textContent = 'å‡†å¤‡å°±ç»ª';
        }

        // ============ çª—å£è°ƒæ•´ ============
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============ åŠ¨ç”»å¾ªç¯ ============
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // æ›´æ–°åœ°çƒ
            if (earth) {
                if (earthRotationEnabled) {
                    earth.rotation.y += 0.001;
                }
                earth.material.uniforms.time.value = time;
            }

            // æ›´æ–°é™¨çŸ³
            if (asteroid && asteroid.visible) {
                asteroid.rotation.x += 0.02;
                asteroid.rotation.y += 0.015;
                asteroid.material.uniforms.time.value = time;

                if (isLaunched && !hasImpacted) {
                    // ç§»åŠ¨é™¨çŸ³
                    asteroid.position.add(asteroidVelocity);

                    // æ›´æ–°å°¾è¿¹
                    if (asteroidTrail.visible) {
                        const positions = asteroidTrail.geometry.attributes.position.array;
                        // ç§»åŠ¨æ‰€æœ‰ç²’å­
                        for (let i = positions.length - 3; i >= 3; i -= 3) {
                            positions[i] = positions[i - 3];
                            positions[i + 1] = positions[i - 2];
                            positions[i + 2] = positions[i - 1];
                        }
                        // æ–°ç²’å­åœ¨é™¨çŸ³ä½ç½®
                        positions[0] = asteroid.position.x + (Math.random() - 0.5) * 2;
                        positions[1] = asteroid.position.y + (Math.random() - 0.5) * 2;
                        positions[2] = asteroid.position.z + (Math.random() - 0.5) * 2;
                        asteroidTrail.geometry.attributes.position.needsUpdate = true;
                    }

                    // æ£€æµ‹æ’å‡»
                    const distance = asteroid.position.distanceTo(earth.position);
                    if (distance < EARTH_RADIUS + ASTEROID_RADIUS) {
                        hasImpacted = true;
                        const impactPoint = asteroid.position.clone();
                        createImpactEffect(impactPoint);
                    }
                }
            }

            // æ›´æ–°çˆ†ç‚¸ç²’å­
            debrisParticles.forEach((explosion, index) => {
                if (explosion.userData.life > 0) {
                    explosion.userData.life -= 0.008;
                    explosion.material.opacity = explosion.userData.life;

                    const positions = explosion.geometry.attributes.position.array;
                    const velocities = explosion.userData.velocities;

                    for (let i = 0; i < velocities.length; i++) {
                        positions[i * 3] += velocities[i].x * 0.5;
                        positions[i * 3 + 1] += velocities[i].y * 0.5;
                        positions[i * 3 + 2] += velocities[i].z * 0.5;

                        // å‡é€Ÿ
                        velocities[i].multiplyScalar(0.98);
                    }
                    explosion.geometry.attributes.position.needsUpdate = true;
                } else {
                    scene.remove(explosion);
                    debrisParticles.splice(index, 1);
                }
            });

            // æ›´æ–°å†²å‡»æ³¢
            if (shockwave) {
                shockwave.userData.scale += 0.5;
                shockwave.scale.set(shockwave.userData.scale, shockwave.userData.scale, 1);
                shockwave.material.opacity -= 0.02;

                if (shockwave.material.opacity <= 0) {
                    scene.remove(shockwave);
                    shockwave = null;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ============ å¯åŠ¨ ============
        init();
    </script>
</body>
</html>
