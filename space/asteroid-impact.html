<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é™¨çŸ³æ’å‡»åœ°çƒ - æŸ³æ™ºå¤©çš„å®‡å®™è¯¾å ‚</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700;900&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Noto Sans SC', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            min-height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
            pointer-events: none;
        }

        .header > * { pointer-events: auto; }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, #ff6b35, #ff4500);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.5);
        }

        .logo-text h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            color: #ff6b35;
            text-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        .logo-text p {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
        }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            color: rgba(255,255,255,0.7);
            text-decoration: none;
            font-size: 0.85rem;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        .controls {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 30px;
            backdrop-filter: blur(10px);
        }

        .control-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: linear-gradient(145deg, #ff6b35, #ff4500);
            border: none;
            border-radius: 20px;
            color: #fff;
            font-family: 'Noto Sans SC', sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 69, 0, 0.4);
        }

        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 25px rgba(255, 69, 0, 0.6);
        }

        .control-btn:disabled {
            background: #444;
            cursor: not-allowed;
            box-shadow: none;
        }

        .control-btn.secondary {
            background: rgba(255,255,255,0.1);
            box-shadow: none;
        }

        .control-btn.secondary:hover {
            background: rgba(255,255,255,0.2);
            box-shadow: none;
        }

        .info-panel {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 320px;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
            z-index: 100;
            background: rgba(0,0,0,0.75);
            border: 1px solid rgba(255,107,53,0.3);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .info-panel h2 {
            font-size: 1.2rem;
            color: #ff6b35;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-panel p {
            font-size: 0.9rem;
            line-height: 1.7;
            color: rgba(255,255,255,0.85);
            margin-bottom: 12px;
        }

        .info-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .info-section h3 {
            font-size: 1rem;
            color: #ffd93d;
            margin-bottom: 8px;
        }

        .fact-list {
            list-style: none;
        }

        .fact-list li {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.75);
            padding: 6px 0;
            padding-left: 20px;
            position: relative;
        }

        .fact-list li::before {
            content: 'â˜„ï¸';
            position: absolute;
            left: 0;
            font-size: 0.8rem;
        }

        .status-display {
            position: fixed;
            left: 20px;
            bottom: 100px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: rgba(255,255,255,0.8);
            margin: 4px 0;
        }

        .status-value {
            color: #ff6b35;
            font-weight: 700;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a0a00 0%, #000 100%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-icon {
            font-size: 4rem;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .loading-text {
            margin-top: 20px;
            font-size: 1.2rem;
            color: #ff6b35;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .impact-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }

        .impact-flash.active {
            opacity: 1;
            animation: flash-pulse 2s ease-out forwards;
        }

        @keyframes flash-pulse {
            0% { opacity: 1; background: #fff; }
            10% { opacity: 1; background: #fff; }
            30% { opacity: 0.9; background: #fffbe0; }
            60% { opacity: 0.5; background: #ffdd00; }
            100% { opacity: 0; background: transparent; }
        }

        /* ç­ç»æç¤ºè¦†ç›–å±‚ */
        .extinction-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s;
        }

        .extinction-overlay.active {
            opacity: 1;
        }

        .extinction-text {
            font-size: 1.8rem;
            color: #ff6b35;
            text-shadow: 0 0 20px rgba(255, 107, 53, 0.8), 0 0 40px rgba(255, 107, 53, 0.4);
            margin-bottom: 30px;
            font-weight: 700;
            letter-spacing: 2px;
            animation: text-fade-in 1s ease-out;
        }

        @keyframes text-fade-in {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .extinction-icons {
            display: flex;
            gap: 40px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .extinction-icon {
            font-size: 4rem;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.5s ease-out;
            position: relative;
        }

        .extinction-icon.visible {
            opacity: 1;
            transform: scale(1);
        }

        .extinction-icon.fade-out {
            opacity: 0.3;
            filter: grayscale(100%);
            transform: scale(0.8);
        }

        .extinction-icon.extinct::after {
            content: '';
            position: absolute;
            top: 50%;
            left: -10%;
            width: 0;
            height: 6px;
            background: linear-gradient(90deg, #ff4444, #ff0000);
            transform: rotate(-45deg);
            animation: strikethrough 0.4s ease-out forwards;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }

        @keyframes strikethrough {
            from { width: 0; }
            to { width: 120%; }
        }

        .extinction-icon.survive {
            color: #4CAF50;
            text-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
        }

        .home-btn {
            position: fixed;
            left: 20px;
            bottom: 20px;
            z-index: 100;
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 20px;
            color: rgba(255,255,255,0.6);
            text-decoration: none;
            font-size: 0.85rem;
            backdrop-filter: blur(8px);
            transition: all 0.3s;
        }

        .home-btn:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        @media (max-width: 768px) {
            .info-panel {
                display: none;
            }
            .controls {
                flex-wrap: wrap;
                justify-content: center;
                width: 90%;
            }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-icon">â˜„ï¸</div>
        <div class="loading-text">æ­£åœ¨åŠ è½½é™¨çŸ³æ’å‡»æ¨¡æ‹Ÿ...</div>
    </div>

    <div class="impact-flash" id="impactFlash"></div>

    <!-- ç­ç»æç¤ºè¦†ç›–å±‚ -->
    <div id="extinctionOverlay" class="extinction-overlay">
        <div class="extinction-text" id="extinctionText"></div>
        <div class="extinction-icons" id="extinctionIcons"></div>
    </div>

    <div id="canvas-container"></div>

    <div class="header">
        <div class="logo">
            <div class="logo-icon">â˜„ï¸</div>
            <div class="logo-text">
                <h1>ASTEROID IMPACT</h1>
                <p>é™¨çŸ³æ’å‡»åœ°çƒ</p>
            </div>
        </div>
        <a href="solar-system.html" class="back-btn">
            <span>â†</span>
            <span>è¿”å›å¤ªé˜³ç³»</span>
        </a>
    </div>

    <div class="info-panel">
        <h2>â˜„ï¸ ä»€ä¹ˆæ˜¯é™¨çŸ³ï¼Ÿ</h2>
        <p>é™¨çŸ³æ˜¯æ¥è‡ªå¤ªç©ºçš„å²©çŸ³æˆ–é‡‘å±ç¢ç‰‡ï¼Œå½“å®ƒä»¬ç©¿è¿‡åœ°çƒå¤§æ°”å±‚å¹¶è½åˆ°åœ°é¢æ—¶ï¼Œå°±è¢«ç§°ä¸ºé™¨çŸ³ã€‚</p>
        <p>åœ¨å¤ªç©ºä¸­é£è¡Œæ—¶ï¼Œå®ƒä»¬å«åš<strong style="color:#ffd93d">æµæ˜Ÿä½“</strong>ï¼›è¿›å…¥å¤§æ°”å±‚ç‡ƒçƒ§å‘å…‰æ—¶å«åš<strong style="color:#ffd93d">æµæ˜Ÿ</strong>ï¼›è½åˆ°åœ°é¢åæ‰å«<strong style="color:#ffd93d">é™¨çŸ³</strong>ã€‚</p>

        <div class="info-section">
            <h3>ğŸ”¥ é™¨çŸ³æ’å‡»çš„å¨åŠ›</h3>
            <ul class="fact-list">
                <li>å°é™¨çŸ³ï¼ˆ1ç±³ï¼‰ä¼šåœ¨å¤§æ°”å±‚ä¸­ç‡ƒçƒ§æ®†å°½</li>
                <li>ä¸­ç­‰é™¨çŸ³ï¼ˆ50ç±³ï¼‰èƒ½æ‘§æ¯ä¸€åº§åŸå¸‚</li>
                <li>å¤§é™¨çŸ³ï¼ˆ10å…¬é‡Œï¼‰å¯èƒ½å¯¼è‡´ç‰©ç§ç­ç»</li>
                <li>6500ä¸‡å¹´å‰ï¼Œä¸€é¢—10å…¬é‡Œçš„é™¨çŸ³å¯¼è‡´æé¾™ç­ç»</li>
            </ul>
        </div>

        <div class="info-section">
            <h3>ğŸŒ è‘—åé™¨çŸ³å‘</h3>
            <ul class="fact-list">
                <li>ç¾å›½äºšåˆ©æ¡‘é‚£é™¨çŸ³å‘ï¼šç›´å¾„1.2å…¬é‡Œ</li>
                <li>å¢¨è¥¿å“¥å¸Œå…‹è‹é²ä¼¯å‘ï¼šç›´å¾„180å…¬é‡Œï¼ˆæé¾™ç­ç»ï¼‰</li>
                <li>å—éå¼—é‡Œå¾·å ¡å‘ï¼šç›´å¾„300å…¬é‡Œï¼ˆæœ€å¤§ï¼‰</li>
            </ul>
        </div>

        <div class="info-section">
            <h3>ğŸ’ é™¨çŸ³çš„ç±»å‹</h3>
            <ul class="fact-list">
                <li><strong>çŸ³é™¨çŸ³</strong>ï¼šä¸»è¦ç”±ç¡…é…¸ç›çŸ¿ç‰©ç»„æˆ</li>
                <li><strong>é“é™¨çŸ³</strong>ï¼šä¸»è¦ç”±é“å’Œé•ç»„æˆ</li>
                <li><strong>çŸ³é“é™¨çŸ³</strong>ï¼šå²©çŸ³å’Œé‡‘å±çš„æ··åˆç‰©</li>
            </ul>
        </div>
    </div>

    <div class="status-display" id="statusDisplay">
        <div class="status-item">
            <span>ğŸ“ é™¨çŸ³ç›´å¾„:</span>
            <span class="status-value" id="asteroidSize">500 ç±³</span>
        </div>
        <div class="status-item">
            <span>ğŸš€ æ’å‡»é€Ÿåº¦:</span>
            <span class="status-value" id="impactSpeed">20 km/s</span>
        </div>
        <div class="status-item">
            <span>ğŸ’¥ æ’å‡»çŠ¶æ€:</span>
            <span class="status-value" id="impactStatus">å‡†å¤‡å°±ç»ª</span>
        </div>
    </div>

    <div class="controls">
        <button class="control-btn" id="launchBtn" onclick="launchAsteroid()">
            <span>ğŸš€</span>
            <span>å‘å°„é™¨çŸ³</span>
        </button>
        <button class="control-btn secondary" id="resetBtn" onclick="resetScene()">
            <span>ğŸ”„</span>
            <span>é‡ç½®</span>
        </button>
    </div>

    <a href="../index.html" class="home-btn">ğŸ  é¦–é¡µ</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // ============ å…¨å±€å˜é‡ ============
        let scene, camera, renderer, controls;
        let earth, asteroid, atmosphere;
        let particles = [];
        let impactCrater = null;
        let debrisParticles = [];
        let shockwave = null;
        let fireParticles = [];
        let globalDebris = [];  // å…¨çƒé£çŸ³

        let isLaunched = false;
        let hasImpacted = false;
        let asteroidVelocity = new THREE.Vector3();
        let earthRotationEnabled = true;
        let cameraZoomingToCrater = false;
        let impactPointGlobal = null;

        // ç¯å…‰å¼•ç”¨ï¼ˆä¾¿äºåŠ¨æ€è°ƒæš—ï¼‰
        let sunLight = null;
        let ambientLight = null;

        // ç­ç»æ—¶é—´çº¿æ§åˆ¶
        let extinctionTimeline = {
            phase: 0,
            startTime: 0,
            isActive: false
        };

        const EARTH_RADIUS = 50;
        const ASTEROID_RADIUS = 10;
        const IMPACT_SPEED = 1.2;

        // ç­ç»äº‹ä»¶æ—¶é—´çº¿ï¼ˆå‹ç¼©ç‰ˆï¼Œçº¦35ç§’ï¼‰
        const EXTINCTION_EVENTS = [
            { time: 0, text: 'æ’å‡»ï¼ï¼å·¨å¤§çš„èƒ½é‡é‡Šæ”¾ï¼', icon: null },
            { time: 4000, text: 'å°˜åŸƒå¼€å§‹å¼¥æ¼«æ•´ä¸ªå¤§æ°”å±‚...', icon: null },
            { time: 9000, text: 'é˜³å…‰è¢«å°˜åŸƒé®æŒ¡...', icon: null },
            { time: 14000, text: 'åœ°çƒè¿›å…¥æ¼«é•¿çš„é»‘æš—æ—¶æœŸ', icon: null },
            { time: 18000, text: 'æ¤ç‰©æ— æ³•è¿›è¡Œå…‰åˆä½œç”¨', icon: 'ğŸŒ¿', action: 'fadeOut' },
            { time: 23000, text: 'é£Ÿè‰æé¾™å¤±å»é£Ÿç‰©æ¥æº', icon: 'ğŸ¦•', action: 'extinct' },
            { time: 28000, text: 'é£Ÿè‚‰æé¾™ä¹Ÿæ— æ³•å­˜æ´»', icon: 'ğŸ¦–', action: 'extinct' },
            { time: 32000, text: 'åœ°çƒä¸Š75%çš„ç‰©ç§æ¶ˆå¤±äº†...', icon: null },
            { time: 36000, text: 'ä½†ç”Ÿå‘½å¹¶æœªç»ˆç»“...å°å‹å“ºä¹³åŠ¨ç‰©å­˜æ´»ä¸‹æ¥', icon: 'ğŸ€', action: 'survive' }
        ];

        // ============ åˆå§‹åŒ– ============
        function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000008);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 30, 200);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 80;
            controls.maxDistance = 400;

            // åˆ›å»ºåœºæ™¯å…ƒç´ 
            createStars();
            createEarth();
            createAsteroid();
            createLighting();

            // éšè—åŠ è½½å±å¹•
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
            }, 800);

            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }

        // ============ åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯ ============
        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starPositions = [];

            for (let i = 0; i < 5000; i++) {
                const x = (Math.random() - 0.5) * 4000;
                const y = (Math.random() - 0.5) * 4000;
                const z = (Math.random() - 0.5) * 4000;
                starPositions.push(x, y, z);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));

            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.5,
                sizeAttenuation: true
            });

            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        // ============ åˆ›å»ºåœ°çƒ ============
        function createEarth() {
            const geometry = new THREE.SphereGeometry(EARTH_RADIUS, 128, 128);

            const earthMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    impactPoint: { value: new THREE.Vector3(0, 0, 1) },
                    impactStrength: { value: 0.0 },
                    craterSize: { value: 0.0 },
                    // ç­ç»æ•ˆæœç›¸å…³
                    dustCoverage: { value: 0.0 },
                    dustSpreadCenter: { value: new THREE.Vector3(0, 0, 1) },
                    dustSpreadRadius: { value: 0.0 },
                    globalDarkness: { value: 0.0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;

                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vUv = uv;
                        vPosition = position;
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 impactPoint;
                    uniform float impactStrength;
                    uniform float craterSize;
                    uniform float dustCoverage;
                    uniform vec3 dustSpreadCenter;
                    uniform float dustSpreadRadius;
                    uniform float globalDarkness;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;

                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                    }

                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);
                        float a = hash(i);
                        float b = hash(i + vec2(1.0, 0.0));
                        float c = hash(i + vec2(0.0, 1.0));
                        float d = hash(i + vec2(1.0, 1.0));
                        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                    }

                    float fbm(vec2 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        for (int i = 0; i < 6; i++) {
                            value += amplitude * noise(p);
                            p *= 2.0;
                            amplitude *= 0.5;
                        }
                        return value;
                    }

                    void main() {
                        vec2 uv = vUv;

                        // å¤§é™†
                        float continent = fbm(uv * 8.0 + vec2(1.5, 0.5));
                        continent += fbm(uv * 16.0) * 0.3;
                        float landMask = smoothstep(0.45, 0.55, continent);

                        // æµ·æ´‹
                        vec3 deepOcean = vec3(0.02, 0.08, 0.25);
                        vec3 shallowOcean = vec3(0.1, 0.3, 0.55);
                        vec3 oceanColor = mix(deepOcean, shallowOcean, fbm(uv * 20.0) * 0.5 + 0.3);

                        // é™†åœ°
                        vec3 forest = vec3(0.1, 0.35, 0.15);
                        vec3 plains = vec3(0.25, 0.45, 0.2);
                        vec3 desert = vec3(0.65, 0.55, 0.35);

                        float terrainNoise = fbm(uv * 12.0 + 3.0);
                        vec3 landColor = mix(forest, plains, terrainNoise);

                        float equator = 1.0 - abs(uv.y - 0.5) * 2.0;
                        float desertMask = smoothstep(0.5, 0.7, terrainNoise) * equator;
                        landColor = mix(landColor, desert, desertMask * 0.7);

                        // æåœ°
                        float polar = smoothstep(0.15, 0.0, uv.y) + smoothstep(0.85, 1.0, uv.y);
                        vec3 ice = vec3(0.9, 0.95, 1.0);

                        vec3 surfaceColor = mix(oceanColor, landColor, landMask);
                        surfaceColor = mix(surfaceColor, ice, polar * 0.8);

                        // äº‘å±‚
                        float clouds = fbm(uv * 6.0 + time * 0.008);
                        clouds = smoothstep(0.4, 0.7, clouds);
                        surfaceColor = mix(surfaceColor, vec3(1.0), clouds * 0.35);

                        // é™¨çŸ³å‘æ•ˆæœ - æœˆçƒè¡¨é¢å‘æ´¼è´¨æ„Ÿï¼ˆé™æ€ï¼‰
                        vec3 normalizedPos = normalize(vPosition);
                        float distToImpact = distance(normalizedPos, impactPoint);

                        if (craterSize > 0.0 && distToImpact < craterSize) {
                            float ratio = distToImpact / craterSize;
                            float craterDepth = 1.0 - ratio;
                            craterDepth = pow(craterDepth, 0.5);

                            // æœˆçƒå‘æ´¼çš„ç°è‰²è°ƒ
                            vec3 craterFloor = vec3(0.18, 0.16, 0.14);  // å‘åº•æ·±ç°
                            vec3 craterWall = vec3(0.35, 0.32, 0.28);   // å‘å£ä¸­ç°
                            vec3 craterRim = vec3(0.55, 0.50, 0.45);    // å‘æ²¿æµ…ç°

                            // å‘åº•ç”¨å™ªå£°åšå‡¹å‡¸ä¸å¹³çš„çº¹ç†ï¼ˆé™æ€ï¼Œä¸éšæ—¶é—´å˜åŒ–ï¼‰
                            float bumpNoise = fbm(normalizedPos.xy * 60.0 + normalizedPos.yz * 40.0);
                            float smallBump = noise(normalizedPos.xy * 120.0 + normalizedPos.zz * 80.0);

                            // åˆ†å±‚ï¼šä¸­å¿ƒå¹³å¦å‘åº• â†’ å‘å£ â†’ éš†èµ·çš„è¾¹ç¼˜
                            float floorMask = smoothstep(0.0, 0.35, ratio);
                            float wallMask = smoothstep(0.35, 0.7, ratio);
                            float rimMask = smoothstep(0.7, 0.92, ratio);

                            vec3 craterColor = mix(craterFloor, craterWall, floorMask);
                            craterColor = mix(craterColor, craterRim, rimMask);

                            // å‘åº•æ·»åŠ é™æ€å‡¹å‡¸çº¹ç†ï¼ˆåƒæœˆçƒè¡¨é¢å°å‘ï¼‰
                            float microCraters = smoothstep(0.55, 0.65, bumpNoise) * (1.0 - ratio);
                            craterColor = mix(craterColor, craterFloor * 0.6, microCraters * 0.5);

                            // å‘å£ä¸Šçš„ç»†çº¹ç†
                            float wallTexture = smallBump * 0.15 * (1.0 - abs(ratio - 0.5) * 2.0);
                            craterColor += vec3(wallTexture);

                            // è¾¹ç¼˜éš†èµ·é«˜äº®ï¼ˆé˜³å…‰ç…§åˆ°éš†èµ·éƒ¨åˆ†ï¼‰
                            float rimHighlight = smoothstep(0.82, 0.92, ratio) * smoothstep(1.0, 0.92, ratio);
                            craterColor += vec3(0.2, 0.18, 0.15) * rimHighlight;

                            surfaceColor = mix(surfaceColor, craterColor, craterDepth);
                        }

                        // === å°˜åŸƒè¦†ç›–æ•ˆæœ ===
                        if (dustCoverage > 0.0) {
                            // è®¡ç®—å½“å‰ç‚¹åˆ°æ‰©æ•£ä¸­å¿ƒçš„çƒé¢è·ç¦»
                            float sphereDist = acos(clamp(dot(normalize(vPosition), dustSpreadCenter), -1.0, 1.0));
                            float dustEdge = smoothstep(dustSpreadRadius, max(dustSpreadRadius - 0.5, 0.0), sphereDist);

                            // å°˜åŸƒå¯†åº¦å™ªå£°ï¼ˆæ¨¡æ‹Ÿä¸å‡åŒ€çš„ç°äº‘ï¼‰
                            float dustNoise = fbm(vPosition.xy * 3.0 + vPosition.yz * 2.0 + time * 0.01);
                            float dustDensity = dustCoverage * dustEdge * (0.6 + dustNoise * 0.4);

                            // å°˜åŸƒå±‚é¢œè‰²
                            vec3 dustColor = vec3(0.45, 0.42, 0.38);
                            vec3 darkDustColor = vec3(0.28, 0.25, 0.22);
                            vec3 dustMix = mix(dustColor, darkDustColor, dustNoise * 0.6);

                            // æ··åˆå°˜åŸƒ
                            surfaceColor = mix(surfaceColor, dustMix, dustDensity * 0.92);
                        }

                        // === å…¨çƒå˜æš—æ•ˆæœ ===
                        surfaceColor *= (1.0 - globalDarkness * 0.75);

                        // å¤§æ°”æ•£å°„
                        float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
                        vec3 atmosphereCol = vec3(0.3, 0.6, 1.0);
                        surfaceColor = mix(surfaceColor, atmosphereCol, fresnel * 0.3);

                        // å…‰ç…§
                        vec3 lightDir = normalize(vec3(-1.0, 0.3, 0.5));
                        float diff = max(dot(vNormal, lightDir), 0.0);
                        surfaceColor *= (diff * 0.6 + 0.4);

                        gl_FragColor = vec4(surfaceColor, 1.0);
                    }
                `
            });

            earth = new THREE.Mesh(geometry, earthMaterial);
            scene.add(earth);

            // å¤§æ°”å±‚
            const atmosphereGeometry = new THREE.SphereGeometry(EARTH_RADIUS * 1.12, 64, 64);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    turbidity: { value: 0.0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float turbidity;
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.65 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.5);
                        // æ­£å¸¸å¤§æ°”è‰²ï¼ˆè“è‰²ï¼‰
                        vec3 clearAtmo = vec3(0.3, 0.6, 1.0);
                        // æµ‘æµŠå¤§æ°”è‰²ï¼ˆç°è¤è‰²ï¼‰
                        vec3 dustyAtmo = vec3(0.55, 0.48, 0.40);
                        vec3 atmoColor = mix(clearAtmo, dustyAtmo, turbidity);
                        float opacity = intensity * (0.5 + turbidity * 0.35);
                        gl_FragColor = vec4(atmoColor, opacity);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false
            });

            atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);
        }

        // ============ åˆ›å»ºé™¨çŸ³ ============
        function createAsteroid() {
            // åˆ›å»ºä¸è§„åˆ™çš„é™¨çŸ³å‡ ä½•ä½“
            const geometry = new THREE.IcosahedronGeometry(ASTEROID_RADIUS, 3);

            // è®©é¡¶ç‚¹éšæœºåç§»ï¼Œå½¢æˆå‘å‘æ´¼æ´¼çš„æ•ˆæœ
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);

                const noise = (Math.random() - 0.5) * 0.8;
                const length = Math.sqrt(x*x + y*y + z*z);
                const factor = 1 + noise * 0.3;

                positions.setX(i, x * factor);
                positions.setY(i, y * factor);
                positions.setZ(i, z * factor);
            }
            geometry.computeVertexNormals();

            // é™¨çŸ³æè´¨
            const asteroidMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;

                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;

                    float hash(vec3 p) {
                        return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
                    }

                    float noise(vec3 p) {
                        vec3 i = floor(p);
                        vec3 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);

                        float n = mix(
                            mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),
                                mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                            mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                        return n;
                    }

                    void main() {
                        // åŸºç¡€å²©çŸ³é¢œè‰² - æ›´äº®æ›´æ¸…æ™°
                        vec3 rockDark = vec3(0.35, 0.28, 0.22);
                        vec3 rockLight = vec3(0.65, 0.58, 0.50);
                        vec3 rockRust = vec3(0.70, 0.45, 0.30);

                        float n = noise(vPosition * 2.0);
                        float n2 = noise(vPosition * 5.0);

                        vec3 rockColor = mix(rockDark, rockLight, n);
                        rockColor = mix(rockColor, rockRust, n2 * 0.4);

                        // é™¨çŸ³å‘çº¹ç†
                        float craters = noise(vPosition * 8.0);
                        craters = smoothstep(0.5, 0.7, craters);
                        rockColor = mix(rockColor, rockDark * 0.7, craters * 0.4);

                        // é‡‘å±å…‰æ³½ï¼ˆé“é™¨çŸ³ç‰¹å¾ï¼‰
                        float metallic = noise(vPosition * 3.0 + 10.0);
                        vec3 metalColor = vec3(0.75, 0.70, 0.65);
                        rockColor = mix(rockColor, metalColor, metallic * 0.25);

                        // å…‰ç…§ - æ›´äº®
                        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                        float diff = max(dot(vNormal, lightDir), 0.0);
                        float ambient = 0.45;

                        vec3 finalColor = rockColor * (diff * 0.6 + ambient);

                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });

            asteroid = new THREE.Mesh(geometry, asteroidMaterial);
            // é™¨çŸ³ä»è¿œå¤„å·¦ä¸Šæ–¹é£æ¥ï¼Œé•¿è·ç¦»é£è¡Œåæ’å‡»åœ°çƒæ­£é¢
            // xè´Ÿ(å·¦)è¾ƒå¤§, yæ­£(ä¸Š)è¾ƒå¤§, zè´Ÿ(åæ–¹)ç¡®ä¿æ’å‡»æ­£é¢
            asteroid.position.set(-220, 120, -280);
            scene.add(asteroid);

            // æ·»åŠ é™¨çŸ³å°¾è¿¹ï¼ˆç‡ƒçƒ§æ•ˆæœï¼‰
            createAsteroidTrail();
        }

        // ============ é™¨çŸ³å°¾è¿¹ ============
        let asteroidTrail = null;

        function createAsteroidTrail() {
            const trailGeometry = new THREE.BufferGeometry();
            const trailCount = 500;
            const positions = new Float32Array(trailCount * 3);
            const colors = new Float32Array(trailCount * 3);
            const sizes = new Float32Array(trailCount);

            for (let i = 0; i < trailCount; i++) {
                positions[i * 3] = asteroid.position.x;
                positions[i * 3 + 1] = asteroid.position.y;
                positions[i * 3 + 2] = asteroid.position.z;

                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.5;
                colors[i * 3 + 2] = 0.1;

                sizes[i] = Math.random() * 3 + 1;
            }

            trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            trailGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const trailMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            asteroidTrail = new THREE.Points(trailGeometry, trailMaterial);
            asteroidTrail.visible = false;
            scene.add(asteroidTrail);
        }

        // ============ ç¯å…‰ ============
        function createLighting() {
            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(-100, 50, 100);
            scene.add(sunLight);
        }

        // ============ å‘å°„é™¨çŸ³ ============
        function launchAsteroid() {
            if (isLaunched) return;

            isLaunched = true;
            document.getElementById('launchBtn').disabled = true;
            document.getElementById('impactStatus').textContent = 'æ­£åœ¨æ¥è¿‘...';

            // è®¡ç®—æ’å‡»æ–¹å‘
            const direction = new THREE.Vector3();
            direction.subVectors(earth.position, asteroid.position).normalize();
            asteroidVelocity.copy(direction).multiplyScalar(IMPACT_SPEED);

            // æ˜¾ç¤ºå°¾è¿¹
            asteroidTrail.visible = true;
        }

        // ============ æ’å‡»æ•ˆæœ ============
        function createImpactEffect(impactPoint) {
            // å±å¹•é—ªç™½ï¼ˆå¢å¼ºç‰ˆï¼Œ2ç§’æ¸å˜ï¼‰
            const flash = document.getElementById('impactFlash');
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 2000);

            // éšè—é™¨çŸ³
            asteroid.visible = false;
            asteroidTrail.visible = false;
            earthRotationEnabled = false;
            controls.enabled = false;
            impactPointGlobal = impactPoint.clone();

            // === å…³é”®ï¼šé—ªç™½æœŸé—´å°†ç›¸æœºç¬é—´åˆ‡åˆ°æ’å‡»é¢ï¼Œè®©çˆ†ç‚¸å¯è§ ===
            const impactNormal = impactPoint.clone().normalize();
            const viewPos = impactNormal.clone().multiplyScalar(EARTH_RADIUS + 150);
            viewPos.y += 30;
            camera.position.copy(viewPos);
            const lookTarget = impactNormal.clone().multiplyScalar(EARTH_RADIUS);
            controls.target.copy(lookTarget);
            camera.lookAt(lookTarget);

            // ç›¸æœºéœ‡åŠ¨ - æ›´å¼ºçƒˆã€æ›´æŒä¹…
            const shakeOrigin = camera.position.clone();
            let shakeTime = 0;
            const shakeInterval = setInterval(() => {
                shakeTime += 0.02;
                if (shakeTime > 3) {
                    camera.position.copy(shakeOrigin);
                    clearInterval(shakeInterval);
                    return;
                }
                const intensity = (1 - shakeTime / 3) * 12;
                camera.position.x = shakeOrigin.x + (Math.random() - 0.5) * intensity;
                camera.position.y = shakeOrigin.y + (Math.random() - 0.5) * intensity;
                camera.position.z = shakeOrigin.z + (Math.random() - 0.5) * intensity;
            }, 16);

            // åæ ‡è½¬æ¢
            const impactDir = impactPoint.clone().normalize();
            const inverseRotation = new THREE.Quaternion().setFromEuler(earth.rotation).invert();
            impactDir.applyQuaternion(inverseRotation);
            earth.material.uniforms.impactPoint.value.copy(impactDir);
            earth.material.uniforms.dustSpreadCenter.value.copy(impactDir);

            // === ç¬¬1é˜¶æ®µï¼šæå¼ºé—ªå…‰ + çˆ†ç‚¸ + ç¢ç‰‡é£æº…ï¼ˆ0-2ç§’ï¼‰===
            createIntenseFlash(impactPoint);          // å¼ºé—ªå…‰
            createExplosionParticles(impactPoint);    // ç«ç„°ç²’å­
            createRockDebris(impactPoint);            // å²©çŸ³ç¢ç‰‡
            createShockwave(impactPoint);             // å†²å‡»æ³¢

            document.getElementById('impactStatus').textContent = 'æ’å‡»ï¼ï¼';

            // === ç¬¬2é˜¶æ®µï¼šç†Šç†Šçƒˆç«ï¼ˆ0.5-3ç§’ï¼‰===
            setTimeout(() => {
                createFireball(impactPoint);
            }, 500);

            // === ç¬¬3é˜¶æ®µï¼šæ˜¾ç¤ºé™¨çŸ³å‘ï¼ˆ3-5ç§’ï¼‰===
            setTimeout(() => {
                let craterGrowth = 0;
                const craterInterval = setInterval(() => {
                    craterGrowth += 0.012;
                    if (craterGrowth > 0.4) {
                        clearInterval(craterInterval);
                        earth.material.uniforms.impactStrength.value = 0;
                        return;
                    }
                    earth.material.uniforms.craterSize.value = craterGrowth;
                    earth.material.uniforms.impactStrength.value = 0;
                }, 30);
            }, 3000);

            // === å¯åŠ¨ç­ç»äº‹ä»¶æ—¶é—´çº¿ ===
            startExtinctionEvent(impactPoint);
        }

        // ============ å²©çŸ³ç¢ç‰‡ ============
        function createRockDebris(center) {
            const debrisCount = 60;
            for (let i = 0; i < debrisCount; i++) {
                const size = Math.random() * 1.5 + 0.5;
                const geometry = new THREE.IcosahedronGeometry(size, 0);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(
                        0.4 + Math.random() * 0.3,
                        0.3 + Math.random() * 0.2,
                        0.2 + Math.random() * 0.1
                    )
                });
                const debris = new THREE.Mesh(geometry, material);
                debris.position.copy(center);

                // ä»æ’å‡»ç‚¹å‘å¤–é£æ•£
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                vel.add(center.clone().normalize().multiplyScalar(0.8));
                vel.normalize().multiplyScalar(Math.random() * 2.5 + 1);

                debris.userData.velocity = vel;
                debris.userData.rotSpeed = new THREE.Vector3(
                    Math.random() * 0.2, Math.random() * 0.2, Math.random() * 0.2
                );
                debris.userData.life = 1.0;
                debris.userData.fadeSpeed = 0.005 + Math.random() * 0.005;

                scene.add(debris);
                debrisParticles.push(debris);
            }
        }

        // ============ æŒç»­ç‡ƒçƒ§çš„ç«çƒ ============
        function createFireball(center) {
            // å¤šæ³¢ç«ç„°ç²’å­
            for (let wave = 0; wave < 3; wave++) {
                setTimeout(() => {
                    const particleCount = 600;
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(particleCount * 3);
                    const velocities = [];
                    const colors = new Float32Array(particleCount * 3);

                    const surfacePoint = center.clone().normalize().multiplyScalar(EARTH_RADIUS + 2);

                    for (let i = 0; i < particleCount; i++) {
                        // ç«ç„°ç²’å­å›´ç»•æ’å‡»ç‚¹ç”Ÿæˆ
                        const spread = 8;
                        positions[i * 3] = surfacePoint.x + (Math.random() - 0.5) * spread;
                        positions[i * 3 + 1] = surfacePoint.y + (Math.random() - 0.5) * spread;
                        positions[i * 3 + 2] = surfacePoint.z + (Math.random() - 0.5) * spread;

                        // ç«ç„°å‘ä¸Šå‡è…¾
                        const upDir = center.clone().normalize();
                        const vel = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.8,
                            (Math.random() - 0.5) * 0.8,
                            (Math.random() - 0.5) * 0.8
                        );
                        vel.add(upDir.multiplyScalar(Math.random() * 1.5 + 0.5));
                        velocities.push(vel);

                        // ç«ç„°é¢œè‰²ï¼šç™½â†’é»„â†’æ©™â†’çº¢â†’é»‘çƒŸ
                        const t = Math.random();
                        if (t < 0.15) {
                            // ç™½è‰²é«˜æ¸©æ ¸å¿ƒ
                            colors[i * 3] = 1.0;
                            colors[i * 3 + 1] = 0.95;
                            colors[i * 3 + 2] = 0.8;
                        } else if (t < 0.4) {
                            // äº®é»„è‰²
                            colors[i * 3] = 1.0;
                            colors[i * 3 + 1] = 0.8;
                            colors[i * 3 + 2] = 0.2;
                        } else if (t < 0.7) {
                            // æ©™è‰²
                            colors[i * 3] = 1.0;
                            colors[i * 3 + 1] = 0.4;
                            colors[i * 3 + 2] = 0.05;
                        } else if (t < 0.9) {
                            // æ·±çº¢
                            colors[i * 3] = 0.8;
                            colors[i * 3 + 1] = 0.15;
                            colors[i * 3 + 2] = 0.0;
                        } else {
                            // é»‘çƒŸ
                            colors[i * 3] = 0.15;
                            colors[i * 3 + 1] = 0.12;
                            colors[i * 3 + 2] = 0.1;
                        }
                    }

                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                    const material = new THREE.PointsMaterial({
                        size: 2.5,
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.9,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    });

                    const fire = new THREE.Points(geometry, material);
                    fire.userData.velocities = velocities;
                    fire.userData.life = 1.0;
                    fire.userData.fadeSpeed = 0.006;
                    scene.add(fire);
                    debrisParticles.push(fire);
                }, wave * 400);
            }
        }

        // ============ ç›¸æœºæ¨è¿‘é™¨çŸ³å‘ ============
        function zoomToCrater(impactPoint) {
            cameraZoomingToCrater = true;
            controls.enabled = false;

            // è®¡ç®—é™¨çŸ³å‘ä½ç½®ï¼ˆåœ°çƒè¡¨é¢ï¼‰
            const craterNormal = impactPoint.clone().normalize();
            const craterPos = craterNormal.clone().multiplyScalar(EARTH_RADIUS);

            // ç›¸æœºç›®æ ‡ä½ç½®ï¼šä»é™¨çŸ³å‘æ­£ä¸Šæ–¹ï¼ˆæ²¿æ³•çº¿æ–¹å‘ï¼‰å¾€å¤–åç§»
            // åŒæ—¶ç¨å¾®åç§»ä¸€ç‚¹è§’åº¦ï¼Œè®©è§†è§’æ›´è‡ªç„¶
            const cameraDistance = 45;
            const targetCameraPos = craterNormal.clone().multiplyScalar(EARTH_RADIUS + cameraDistance);

            // ç¨å¾®å‘ä¸Šåç§»ä¸€ç‚¹ï¼Œç»™ä¸€ä¸ªä¿¯è§†è§’åº¦
            targetCameraPos.y += 15;

            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const endTarget = craterPos.clone();

            const duration = 2500;
            const startTime = performance.now();

            function animateCamera() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // æ›´å¹³æ»‘çš„ç¼“åŠ¨å‡½æ•°
                const eased = 1 - Math.pow(1 - progress, 4);

                // æ’å€¼ç›¸æœºä½ç½®
                camera.position.lerpVectors(startPos, targetCameraPos, eased);

                // æ’å€¼è§‚å¯Ÿç›®æ ‡
                controls.target.lerpVectors(startTarget, endTarget, eased);

                // æ›´æ–°ç›¸æœºæœå‘
                camera.lookAt(controls.target);

                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                } else {
                    cameraZoomingToCrater = false;
                    controls.enabled = true;
                    controls.minDistance = 20;
                    controls.update();
                    document.getElementById('impactStatus').textContent = 'è§‚å¯Ÿé™¨çŸ³å‘';
                }
            }

            animateCamera();
        }

        // ============ çˆ†ç‚¸ç²’å­ ============
        function createExplosionParticles(center) {
            const particleCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = center.x;
                positions[i * 3 + 1] = center.y;
                positions[i * 3 + 2] = center.z;

                // éšæœºé€Ÿåº¦æ–¹å‘ï¼ˆå¤§éƒ¨åˆ†å‘å¤–ï¼‰
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                vel.add(center.clone().normalize().multiplyScalar(0.5));
                vel.normalize().multiplyScalar(Math.random() * 3 + 1);
                velocities.push(vel);

                // ç«ç„°é¢œè‰²æ¸å˜
                const t = Math.random();
                if (t < 0.3) {
                    colors[i * 3] = 1.0;
                    colors[i * 3 + 1] = 0.9;
                    colors[i * 3 + 2] = 0.5;
                } else if (t < 0.7) {
                    colors[i * 3] = 1.0;
                    colors[i * 3 + 1] = 0.4;
                    colors[i * 3 + 2] = 0.1;
                } else {
                    colors[i * 3] = 0.5;
                    colors[i * 3 + 1] = 0.1;
                    colors[i * 3 + 2] = 0.0;
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const explosion = new THREE.Points(geometry, material);
            explosion.userData.velocities = velocities;
            explosion.userData.life = 1.0;
            scene.add(explosion);
            debrisParticles.push(explosion);
        }

        // ============ å†²å‡»æ³¢ ============
        function createShockwave(center) {
            const geometry = new THREE.RingGeometry(0.1, 1, 64);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });

            shockwave = new THREE.Mesh(geometry, material);
            shockwave.position.copy(center);
            shockwave.lookAt(earth.position);
            shockwave.userData.scale = 1;
            scene.add(shockwave);
        }

        // ============ å¼ºé—ªå…‰æ•ˆæœ ============
        function createIntenseFlash(impactPoint) {
            // æ ¸å¿ƒé«˜äº®ç‚¹å…‰æº
            const coreLight = new THREE.PointLight(0xffffff, 80, 600);
            coreLight.position.copy(impactPoint);
            scene.add(coreLight);

            // å¤–å±‚æš–è‰²å…‰æ™•
            const haloLight = new THREE.PointLight(0xffaa00, 50, 800);
            haloLight.position.copy(impactPoint);
            scene.add(haloLight);

            // æ¸å˜æ¶ˆé€€
            let flashIntensity = 1.0;
            const fadeInterval = setInterval(() => {
                flashIntensity -= 0.015;
                coreLight.intensity = 80 * flashIntensity;
                haloLight.intensity = 50 * flashIntensity;

                if (flashIntensity <= 0) {
                    scene.remove(coreLight);
                    scene.remove(haloLight);
                    clearInterval(fadeInterval);
                }
            }, 16);
        }

        // ============ å…¨çƒé£çŸ³ç³»ç»Ÿ ============
        function createGlobalDebris(impactPoint) {
            const debrisCount = 350;
            const impactNormal = impactPoint.clone().normalize();

            // æ„å»ºæ­£äº¤åŸº
            let tangent = new THREE.Vector3(1, 0, 0);
            if (Math.abs(impactNormal.x) > 0.9) tangent.set(0, 1, 0);
            tangent.crossVectors(tangent, impactNormal).normalize();
            const bitangent = new THREE.Vector3().crossVectors(impactNormal, tangent);

            for (let i = 0; i < debrisCount; i++) {
                const size = Math.random() * 2.5 + 0.4;
                const geometry = new THREE.IcosahedronGeometry(size, Math.random() > 0.7 ? 1 : 0);

                // å˜å½¢ä½¿å…¶æ›´ä¸è§„åˆ™
                const positions = geometry.attributes.position;
                for (let j = 0; j < positions.count; j++) {
                    const noise = (Math.random() - 0.5) * 0.5;
                    positions.setX(j, positions.getX(j) * (1 + noise * 0.3));
                    positions.setY(j, positions.getY(j) * (1 + noise * 0.3));
                    positions.setZ(j, positions.getZ(j) * (1 + noise * 0.3));
                }
                geometry.computeVertexNormals();

                // å¸¦ç«ç„°çš„æè´¨
                const isOnFire = Math.random() > 0.25;
                const material = new THREE.MeshBasicMaterial({
                    color: isOnFire
                        ? new THREE.Color(1, 0.5 + Math.random() * 0.4, 0.1)
                        : new THREE.Color(0.4 + Math.random() * 0.2, 0.3, 0.2),
                    transparent: true,
                    opacity: 1
                });

                const debris = new THREE.Mesh(geometry, material);
                debris.position.copy(impactPoint);

                // æ•£å°„æ–¹å‘ï¼ˆè¦†ç›–æ•´ä¸ªçƒé¢ï¼‰
                const spreadAngle = Math.random() * Math.PI * 0.85;
                const rotationAngle = Math.random() * Math.PI * 2;

                const vel = impactNormal.clone()
                    .multiplyScalar(Math.cos(spreadAngle))
                    .add(tangent.clone().multiplyScalar(Math.sin(spreadAngle) * Math.cos(rotationAngle)))
                    .add(bitangent.clone().multiplyScalar(Math.sin(spreadAngle) * Math.sin(rotationAngle)));

                // é€Ÿåº¦åˆ†å¸ƒ
                const speedFactor = Math.random();
                const speed = speedFactor < 0.3
                    ? 2.5 + Math.random() * 2
                    : speedFactor < 0.7
                        ? 1.2 + Math.random()
                        : 0.6 + Math.random() * 0.5;

                vel.normalize().multiplyScalar(speed);

                debris.userData = {
                    velocity: vel,
                    rotSpeed: new THREE.Vector3(
                        Math.random() * 0.25 - 0.125,
                        Math.random() * 0.25 - 0.125,
                        Math.random() * 0.25 - 0.125
                    ),
                    life: 1.0,
                    fadeSpeed: 0.006 + Math.random() * 0.006,  // åŠ å¿«æ¶ˆæ•£
                    isOnFire: isOnFire
                };

                scene.add(debris);
                globalDebris.push(debris);
            }
        }

        // ============ æ›´æ–°å…¨çƒé£çŸ³ ============
        function updateGlobalDebris() {
            for (let i = globalDebris.length - 1; i >= 0; i--) {
                const debris = globalDebris[i];

                debris.userData.life -= debris.userData.fadeSpeed;
                if (debris.userData.life <= 0) {
                    scene.remove(debris);
                    globalDebris.splice(i, 1);
                    continue;
                }

                // ç§»åŠ¨
                debris.position.add(debris.userData.velocity);

                // æ—‹è½¬ç¿»æ»š
                debris.rotation.x += debris.userData.rotSpeed.x;
                debris.rotation.y += debris.userData.rotSpeed.y;
                debris.rotation.z += debris.userData.rotSpeed.z;

                // å¼±é‡åŠ›ï¼ˆå…è®¸é£è¡Œæ›´è¿œï¼‰
                const gravity = debris.position.clone().normalize().multiplyScalar(-0.002);
                debris.userData.velocity.add(gravity);

                // ç©ºæ°”é˜»åŠ›
                debris.userData.velocity.multiplyScalar(0.997);

                // æ·¡å‡º
                debris.material.opacity = debris.userData.life;

                // ç«ç„°æ‹–å°¾
                if (debris.userData.isOnFire && Math.random() > 0.85) {
                    createFireTrail(debris.position.clone());
                }
            }
        }

        // ============ ç«ç„°æ‹–å°¾ ============
        function createFireTrail(position) {
            const trailGeo = new THREE.SphereGeometry(0.4, 4, 4);
            const trailMat = new THREE.MeshBasicMaterial({
                color: new THREE.Color(1, 0.35 + Math.random() * 0.4, 0),
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            const trail = new THREE.Mesh(trailGeo, trailMat);
            trail.position.copy(position);
            trail.userData.life = 0.4;
            trail.userData.fadeSpeed = 0.015;
            trail.userData.velocity = new THREE.Vector3(0, 0, 0);
            trail.userData.rotSpeed = new THREE.Vector3(0, 0, 0);
            scene.add(trail);
            debrisParticles.push(trail);
        }

        // ============ å°˜åŸƒæ‰©æ•£ ============
        function startDustExpansion(impactPoint) {
            const dustCenter = impactPoint.clone().normalize();
            earth.material.uniforms.dustSpreadCenter.value.copy(dustCenter);

            const startTime = performance.now();
            const duration = 10000;  // 10ç§’æ‰©æ•£åˆ°å…¨çƒ

            function animateDust() {
                if (!extinctionTimeline.isActive) return;

                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // ç¼“åŠ¨ï¼šå…ˆå¿«åæ…¢
                const eased = 1 - Math.pow(1 - progress, 2.5);

                // æ‰©æ•£åŠå¾„ä»0åˆ°PIï¼ˆè¦†ç›–æ•´ä¸ªçƒé¢ï¼‰
                earth.material.uniforms.dustSpreadRadius.value = eased * Math.PI;

                // å°˜åŸƒæµ“åº¦é€æ¸å¢åŠ 
                earth.material.uniforms.dustCoverage.value = eased * 0.92;

                if (progress < 1) {
                    requestAnimationFrame(animateDust);
                }
            }

            animateDust();
        }

        // ============ é»‘æš—æ—¶æœŸ ============
        function startDarkeningPeriod() {
            const startTime = performance.now();
            const duration = 10000;  // 10ç§’å˜æš—

            const initialAmbient = 0.5;
            const initialSun = 1.2;
            const targetAmbient = 0.08;
            const targetSun = 0.1;

            function animateDarkness() {
                if (!extinctionTimeline.isActive) return;

                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // ç¼“åŠ¨
                const eased = progress * progress;

                // è°ƒæš—å…‰æº
                if (ambientLight) ambientLight.intensity = initialAmbient - (initialAmbient - targetAmbient) * eased;
                if (sunLight) sunLight.intensity = initialSun - (initialSun - targetSun) * eased;

                // åŒæ­¥æ›´æ–° shader uniform
                earth.material.uniforms.globalDarkness.value = eased;

                // å¤§æ°”æµ‘æµŠåº¦
                if (atmosphere && atmosphere.material.uniforms) {
                    atmosphere.material.uniforms.turbidity.value = eased * 0.85;
                }

                if (progress < 1) {
                    requestAnimationFrame(animateDarkness);
                }
            }

            animateDarkness();
        }

        // ============ ç­ç»æ—¶é—´çº¿ ============
        function startExtinctionTimeline() {
            const overlay = document.getElementById('extinctionOverlay');
            const textEl = document.getElementById('extinctionText');
            const iconsEl = document.getElementById('extinctionIcons');

            overlay.classList.add('active');

            EXTINCTION_EVENTS.forEach(event => {
                setTimeout(() => {
                    if (!extinctionTimeline.isActive) return;

                    // æ›´æ–°æ–‡å­—
                    textEl.textContent = event.text;
                    textEl.style.animation = 'none';
                    textEl.offsetHeight;
                    textEl.style.animation = 'text-fade-in 1s ease-out';

                    // å¤„ç†å›¾æ ‡
                    if (event.icon) {
                        const iconEl = document.createElement('div');
                        iconEl.className = 'extinction-icon';
                        iconEl.textContent = event.icon;
                        iconsEl.appendChild(iconEl);

                        setTimeout(() => iconEl.classList.add('visible'), 100);

                        if (event.action === 'fadeOut') {
                            setTimeout(() => iconEl.classList.add('fade-out'), 2500);
                        } else if (event.action === 'extinct') {
                            setTimeout(() => {
                                iconEl.classList.add('extinct');
                                iconEl.classList.add('fade-out');
                            }, 2000);
                        } else if (event.action === 'survive') {
                            iconEl.classList.add('survive');
                        }
                    }
                }, event.time);
            });
        }

        // ============ å¯åŠ¨ç­ç»äº‹ä»¶ ============
        function startExtinctionEvent(impactPoint) {
            extinctionTimeline.isActive = true;
            extinctionTimeline.startTime = performance.now();
            extinctionTimeline.phase = 1;

            // å¯åŠ¨æ–‡å­—æ—¶é—´çº¿
            startExtinctionTimeline();

            // === é˜¶æ®µ2: ç«ç„°é£çŸ³ï¼ˆ1ç§’åï¼‰===
            setTimeout(() => {
                if (!extinctionTimeline.isActive) return;
                extinctionTimeline.phase = 2;
                document.getElementById('impactStatus').textContent = 'ç†”å²©é£çŸ³å››æ•£...';
                createGlobalDebris(impactPoint);
            }, 1000);

            // === é˜¶æ®µ3: å°˜åŸƒè¦†ç›–ï¼ˆ3ç§’åï¼‰===
            setTimeout(() => {
                if (!extinctionTimeline.isActive) return;
                extinctionTimeline.phase = 3;
                document.getElementById('impactStatus').textContent = 'å°˜åŸƒå¼¥æ¼«...';
                startDustExpansion(impactPoint);
            }, 3000);

            // === é˜¶æ®µ4: é»‘æš—æ—¶æœŸï¼ˆ8ç§’åï¼‰===
            setTimeout(() => {
                if (!extinctionTimeline.isActive) return;
                extinctionTimeline.phase = 4;
                document.getElementById('impactStatus').textContent = 'é˜³å…‰æ¶ˆå¤±...';
                startDarkeningPeriod();
            }, 8000);

            // === é˜¶æ®µ5: ç­ç»å®Œæˆï¼ˆ36ç§’åï¼‰===
            setTimeout(() => {
                if (!extinctionTimeline.isActive) return;
                extinctionTimeline.phase = 5;
                document.getElementById('impactStatus').textContent = 'å¤§ç­ç»...æ–°ç”Ÿå‘½èŒèŠ½';
                controls.enabled = true;
            }, 36000);
        }

        // ============ é‡ç½®åœºæ™¯ ============
        function resetScene() {
            // åœæ­¢ç­ç»æ—¶é—´çº¿
            extinctionTimeline.isActive = false;
            extinctionTimeline.phase = 0;

            // é‡ç½®é™¨çŸ³ä½ç½®ï¼ˆä¸åˆå§‹ä½ç½®ä¸€è‡´ï¼‰
            asteroid.position.set(-220, 120, -280);
            asteroid.visible = true;
            asteroidTrail.visible = false;

            // é‡ç½®çŠ¶æ€
            isLaunched = false;
            hasImpacted = false;
            asteroidVelocity.set(0, 0, 0);
            earthRotationEnabled = true;
            cameraZoomingToCrater = false;
            impactPointGlobal = null;

            // é‡ç½®åœ°çƒæè´¨
            earth.material.uniforms.impactStrength.value = 0;
            earth.material.uniforms.craterSize.value = 0;
            earth.material.uniforms.dustCoverage.value = 0;
            earth.material.uniforms.dustSpreadRadius.value = 0;
            earth.material.uniforms.globalDarkness.value = 0;

            // é‡ç½®å¤§æ°”å±‚
            if (atmosphere && atmosphere.material.uniforms) {
                atmosphere.material.uniforms.turbidity.value = 0;
            }

            // é‡ç½®ç¯å…‰
            if (ambientLight) ambientLight.intensity = 0.5;
            if (sunLight) sunLight.intensity = 1.2;

            // æ¸…é™¤çˆ†ç‚¸ç²’å­
            debrisParticles.forEach(p => scene.remove(p));
            debrisParticles = [];

            // æ¸…é™¤å…¨çƒé£çŸ³
            globalDebris.forEach(p => scene.remove(p));
            globalDebris = [];

            // æ¸…é™¤å†²å‡»æ³¢
            if (shockwave) {
                scene.remove(shockwave);
                shockwave = null;
            }

            // é‡ç½®ç›¸æœºä½ç½®
            camera.position.set(0, 30, 200);
            controls.target.set(0, 0, 0);
            controls.minDistance = 80;
            controls.enabled = true;

            // é‡ç½®UI
            document.getElementById('launchBtn').disabled = false;
            document.getElementById('impactStatus').textContent = 'å‡†å¤‡å°±ç»ª';

            // éšè—ç­ç»æç¤º
            const overlay = document.getElementById('extinctionOverlay');
            overlay.classList.remove('active');
            document.getElementById('extinctionText').textContent = '';
            document.getElementById('extinctionIcons').innerHTML = '';
        }

        // ============ çª—å£è°ƒæ•´ ============
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============ åŠ¨ç”»å¾ªç¯ ============
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // æ›´æ–°åœ°çƒ
            if (earth) {
                if (earthRotationEnabled) {
                    earth.rotation.y += 0.001;
                }
                earth.material.uniforms.time.value = time;
            }

            // æ›´æ–°é™¨çŸ³
            if (asteroid && asteroid.visible) {
                asteroid.rotation.x += 0.02;
                asteroid.rotation.y += 0.015;
                asteroid.material.uniforms.time.value = time;

                if (isLaunched && !hasImpacted) {
                    // ç§»åŠ¨é™¨çŸ³
                    asteroid.position.add(asteroidVelocity);

                    // æ›´æ–°å°¾è¿¹
                    if (asteroidTrail.visible) {
                        const positions = asteroidTrail.geometry.attributes.position.array;
                        // ç§»åŠ¨æ‰€æœ‰ç²’å­
                        for (let i = positions.length - 3; i >= 3; i -= 3) {
                            positions[i] = positions[i - 3];
                            positions[i + 1] = positions[i - 2];
                            positions[i + 2] = positions[i - 1];
                        }
                        // æ–°ç²’å­åœ¨é™¨çŸ³ä½ç½®
                        positions[0] = asteroid.position.x + (Math.random() - 0.5) * 2;
                        positions[1] = asteroid.position.y + (Math.random() - 0.5) * 2;
                        positions[2] = asteroid.position.z + (Math.random() - 0.5) * 2;
                        asteroidTrail.geometry.attributes.position.needsUpdate = true;
                    }

                    // æ£€æµ‹æ’å‡»
                    const distance = asteroid.position.distanceTo(earth.position);
                    if (distance < EARTH_RADIUS + ASTEROID_RADIUS) {
                        hasImpacted = true;
                        const impactPoint = asteroid.position.clone();
                        createImpactEffect(impactPoint);
                    }
                }
            }

            // æ›´æ–°çˆ†ç‚¸ç²’å­å’Œç¢ç‰‡ï¼ˆå€’åºéå†é¿å…spliceé—®é¢˜ï¼‰
            for (let i = debrisParticles.length - 1; i >= 0; i--) {
                const obj = debrisParticles[i];

                if (obj.isMesh) {
                    // å²©çŸ³ç¢ç‰‡ï¼ˆMeshå¯¹è±¡ï¼‰
                    obj.userData.life -= obj.userData.fadeSpeed;
                    if (obj.userData.life <= 0) {
                        scene.remove(obj);
                        debrisParticles.splice(i, 1);
                        continue;
                    }
                    // ç§»åŠ¨
                    obj.position.add(obj.userData.velocity);
                    // æ—‹è½¬ç¿»æ»š
                    obj.rotation.x += obj.userData.rotSpeed.x;
                    obj.rotation.y += obj.userData.rotSpeed.y;
                    obj.rotation.z += obj.userData.rotSpeed.z;
                    // é‡åŠ›ï¼ˆå‘åœ°çƒä¸­å¿ƒï¼‰
                    const gravity = obj.position.clone().normalize().multiplyScalar(-0.01);
                    obj.userData.velocity.add(gravity);
                    // å‡é€Ÿ
                    obj.userData.velocity.multiplyScalar(0.995);
                    // æ·¡å‡º
                    obj.material.transparent = true;
                    obj.material.opacity = obj.userData.life;
                } else {
                    // ç²’å­ç³»ç»Ÿï¼ˆPointså¯¹è±¡ï¼‰
                    const fadeSpeed = obj.userData.fadeSpeed || 0.008;
                    obj.userData.life -= fadeSpeed;

                    if (obj.userData.life <= 0) {
                        scene.remove(obj);
                        debrisParticles.splice(i, 1);
                        continue;
                    }

                    obj.material.opacity = obj.userData.life;

                    const positions = obj.geometry.attributes.position.array;
                    const velocities = obj.userData.velocities;

                    for (let j = 0; j < velocities.length; j++) {
                        positions[j * 3] += velocities[j].x * 0.5;
                        positions[j * 3 + 1] += velocities[j].y * 0.5;
                        positions[j * 3 + 2] += velocities[j].z * 0.5;
                        velocities[j].multiplyScalar(0.98);
                    }
                    obj.geometry.attributes.position.needsUpdate = true;
                }
            }

            // æ›´æ–°å†²å‡»æ³¢
            if (shockwave) {
                shockwave.userData.scale += 0.5;
                shockwave.scale.set(shockwave.userData.scale, shockwave.userData.scale, 1);
                shockwave.material.opacity -= 0.02;

                if (shockwave.material.opacity <= 0) {
                    scene.remove(shockwave);
                    shockwave = null;
                }
            }

            // æ›´æ–°å…¨çƒé£çŸ³
            if (globalDebris.length > 0) {
                updateGlobalDebris();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ============ å¯åŠ¨ ============
        init();
    </script>
</body>
</html>
