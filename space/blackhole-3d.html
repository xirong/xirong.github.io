<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¡å†ˆå›¾é›… 3D - æŸ³æ™ºå¤©çš„å®‡å®™è¯¾å ‚</title>
    <link rel="preconnect" href="https://fonts.loli.net">
    <link href="https://fonts.loli.net/css2?family=Noto+Sans+SC:wght@400;700&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Noto Sans SC', sans-serif; }
        canvas { display: block; }

        .loading {
            position: fixed; inset: 0; z-index: 999; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease;
        }
        .loading.done { opacity: 0; pointer-events: none; }
        .ld-ring {
            width: 80px; height: 80px; position: relative;
        }
        .ld-ring .r {
            position: absolute; inset: 0; border: 3px solid transparent;
            border-top-color: #ffcc66; border-radius: 50%;
            animation: spin 1.2s linear infinite;
        }
        .ld-ring .r:nth-child(2) {
            inset: 12px; border-top-color: #fff;
            animation-duration: 1.8s; animation-direction: reverse;
        }
        .ld-ring .core {
            position: absolute; inset: 25px;
            background: radial-gradient(circle, #000 50%, transparent);
            border-radius: 50%;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .ld-text { margin-top: 20px; color: rgba(255,255,255,0.4); font-size: 0.85rem; letter-spacing: 2px; }

        .header {
            position: fixed; top: 0; left: 0; right: 0; z-index: 100;
            padding: 16px 24px; display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, transparent 100%);
            pointer-events: none;
        }
        .header > * { pointer-events: auto; }
        .logo { display: flex; align-items: center; gap: 12px; }
        .logo-icon {
            width: 42px; height: 42px;
            background: radial-gradient(circle, #000 30%, #ffaa44 55%, #663300 100%);
            border-radius: 50%; font-size: 18px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 20px rgba(255,170,68,0.5);
        }
        .logo h1 {
            font-family: 'Orbitron', sans-serif; font-size: 1.2rem;
            background: linear-gradient(90deg, #ffcc66, #fff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text; letter-spacing: 2px;
        }
        .logo p { font-size: 0.7rem; color: rgba(255,255,255,0.4); }

        .hint {
            position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%);
            z-index: 100; padding: 8px 18px;
            background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px; color: rgba(255,255,255,0.4);
            font-size: 0.75rem; backdrop-filter: blur(8px);
            transition: opacity 2s ease; pointer-events: none;
        }
        .hint.hide { opacity: 0; }

        .home-link {
            position: fixed; bottom: 24px; left: 24px; z-index: 100;
            display: flex; align-items: center; gap: 6px;
            padding: 10px 16px; background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 20px;
            color: rgba(255,255,255,0.5); text-decoration: none; font-size: 0.8rem;
            backdrop-filter: blur(8px); transition: all 0.3s ease;
        }
        .home-link:hover { color: #fff; border-color: #ffcc66; }

        /* çŸ¥è¯†æ ‡æ³¨ */
        .annotations {
            position: fixed; right: 20px; top: 50%; transform: translateY(-50%);
            z-index: 100; display: flex; flex-direction: column; gap: 8px;
        }
        .ann-btn {
            padding: 8px 14px; background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,200,100,0.2); border-radius: 12px;
            color: rgba(255,255,255,0.6); font-size: 0.75rem;
            cursor: pointer; backdrop-filter: blur(8px);
            transition: all 0.3s ease; text-align: left;
        }
        .ann-btn:hover { border-color: #ffcc66; color: #fff; background: rgba(255,170,68,0.15); }
        .ann-btn .ann-title { font-weight: 700; margin-bottom: 2px; }
        .ann-btn .ann-desc { font-size: 0.65rem; color: rgba(255,255,255,0.35); line-height: 1.4; }

        @media (max-width: 600px) {
            .logo h1 { font-size: 1rem; }
            .logo p { display: none; }
            .annotations { right: 10px; }
            .ann-btn { padding: 6px 10px; font-size: 0.65rem; }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="ld-ring"><div class="r"></div><div class="r"></div><div class="core"></div></div>
        <div class="ld-text">æ­£åœ¨æ„å»ºé»‘æ´...</div>
    </div>

    <div class="header">
        <div class="logo">
            <div class="logo-icon">ğŸ•³ï¸</div>
            <div>
                <h1>GARGANTUA</h1>
                <p>3D äº¤äº’ Â· çº¯ä»£ç ç”Ÿæˆ</p>
            </div>
        </div>
    </div>

    <div class="annotations" id="annotations">
        <div class="ann-btn" data-target="singularity">
            <div class="ann-title">âš« å¥‡ç‚¹</div>
            <div class="ann-desc">æ‰€æœ‰è´¨é‡å‹ç¼©åˆ°æ— é™å°çš„ä¸€ä¸ªç‚¹</div>
        </div>
        <div class="ann-btn" data-target="horizon">
            <div class="ann-title">ğŸ”´ äº‹ä»¶è§†ç•Œ</div>
            <div class="ann-desc">è¶Šè¿‡å°±å›ä¸æ¥äº†ï¼Œè¿å…‰ä¹Ÿä¸è¡Œ</div>
        </div>
        <div class="ann-btn" data-target="photon">
            <div class="ann-title">ğŸ’« å…‰å­ç¯</div>
            <div class="ann-desc">å…‰ç»•ç€é»‘æ´è½¬åœˆå½¢æˆçš„å…‰ç¯</div>
        </div>
        <div class="ann-btn" data-target="disk">
            <div class="ann-title">ğŸŒ€ å¸ç§¯ç›˜</div>
            <div class="ann-desc">è¢«å¸å…¥çš„ç‰©è´¨æ—‹è½¬å½¢æˆçš„è¶…é«˜æ¸©ç›˜</div>
        </div>
        <div class="ann-btn" data-target="lens">
            <div class="ann-title">ğŸ”® å¼•åŠ›é€é•œ</div>
            <div class="ann-desc">é»‘æ´å¼¯æ›²èƒŒåçš„å…‰çº¿å½¢æˆçš„å¼§</div>
        </div>
    </div>

    <div class="hint" id="hint">æ‹–æ‹½æ—‹è½¬ / æ»šè½®ç¼©æ”¾ / åŒæŒ‡æåˆ</div>
    <a class="home-link" href="blackhole.html">â† è¿”å›é»‘æ´æ¢ç´¢</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script>
    // ============ ç­‰å¾… Three.js åŠ è½½ ============
    function waitForThree() {
        return new Promise(resolve => {
            if (window.THREE && THREE.EffectComposer) { resolve(); return; }
            const check = setInterval(() => {
                if (window.THREE && THREE.EffectComposer) { clearInterval(check); resolve(); }
            }, 50);
        });
    }

    waitForThree().then(init);

    function init() {
    // ============ åœºæ™¯ ============
    const W = window.innerWidth;
    const H = window.innerHeight;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x010204);

    const camera = new THREE.PerspectiveCamera(55, W / H, 0.1, 500);
    camera.position.set(0, 4, 15);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(W, H);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    // ============ åå¤„ç†ï¼ˆè¾‰å…‰ï¼‰ ============
    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(new THREE.RenderPass(scene, camera));

    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(W, H),
        1.0,   // è¾‰å…‰å¼ºåº¦
        0.35,  // è¾‰å…‰åŠå¾„
        0.3    // è¾‰å…‰é˜ˆå€¼ï¼ˆåªæœ‰çœŸæ­£äº®çš„æ‰å‘å…‰ï¼‰
    );
    composer.addPass(bloomPass);

    // ============ æ§åˆ¶å™¨ ============
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 40;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.3;
    controls.target.set(0, 0, 0);
    controls.addEventListener('start', () => { controls.autoRotate = false; });

    // ============ å¸¸é‡ ============
    const SR = 2.0;          // é»‘æ´çƒåŠå¾„ï¼ˆäº‹ä»¶è§†ç•Œï¼‰
    const DISK_IN = 3.6;     // å¸ç§¯ç›˜å†…åŠå¾„ï¼ˆ> ISCOï¼Œç•™è¶³é»‘æš—é—´éš™é¿å… bloom æ·¹æ²¡ä¸­å¿ƒï¼‰
    const DISK_OUT = 12;     // å¸ç§¯ç›˜å¤–åŠå¾„

    // ============ æ˜Ÿé™…ç©¿è¶Šè‰²æ¿ ============
    // å‚è€ƒç”µå½±ä¸­å¡å†ˆå›¾é›…çš„æ¸©æš–é‡‘æ©™è‰²è°ƒ
    const COL = {
        hotWhite:  [1.0,  0.95, 0.85],   // å†…ä¾§æœ€çƒ­åŒºåŸŸ
        warmGold:  [1.0,  0.75, 0.35],   // é‡‘è‰²ä¸»è°ƒ
        deepOrange:[0.9,  0.45, 0.1],    // æ·±æ©™è‰²
        dimRed:    [0.4,  0.15, 0.05],   // æš—çº¢å¤–ç¼˜
        photon:    [1.0,  0.9,  0.7],    // å…‰å­ç¯
    };

    // é¢œè‰²æ’å€¼
    function lerpColor(a, b, t) {
        return [a[0]+(b[0]-a[0])*t, a[1]+(b[1]-a[1])*t, a[2]+(b[2]-a[2])*t];
    }

    // ============ é»‘æ´çƒä½“ï¼ˆäº‹ä»¶è§†ç•Œï¼‰ ============
    const bhGeo = new THREE.SphereGeometry(SR, 64, 64);
    const bhMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const bhSphere = new THREE.Mesh(bhGeo, bhMat);
    scene.add(bhSphere);

    // ç¨å¤§çš„é®ç½©çƒé˜²æ­¢é€è§†ç©¿é€
    const maskGeo = new THREE.SphereGeometry(SR * 1.003, 64, 64);
    const maskMat = new THREE.MeshBasicMaterial({ color: 0x000000, depthWrite: true });
    scene.add(new THREE.Mesh(maskGeo, maskMat));

    // ============ æ—‹è½¬ç»„ ============
    const diskGroup = new THREE.Group();
    scene.add(diskGroup);

    // ============ å…‰å­ç¯ ============
    // Three.js TorusGeometry é»˜è®¤åœ¨ XY å¹³é¢ï¼Œå¿…é¡»æ—‹è½¬åˆ° XZ å¹³é¢ï¼ˆä¸å¸ç§¯ç›˜åŒå¹³é¢ï¼‰
    // å¤–å…‰å­ç¯ï¼ˆè¾ƒç²—ï¼Œé‡‘è‰²è¾‰å…‰ï¼‰
    const photonRing1 = new THREE.Mesh(
        new THREE.TorusGeometry(SR * 1.04, 0.04, 16, 256),
        new THREE.MeshBasicMaterial({ color: new THREE.Color(1.6, 1.3, 0.9) })
    );
    photonRing1.rotation.x = -Math.PI / 2; // æ—‹è½¬åˆ°æ°´å¹³é¢
    diskGroup.add(photonRing1);

    // å†…å…‰å­ç¯ï¼ˆæç»†ï¼Œç¨äº®ï¼‰
    const photonRing2 = new THREE.Mesh(
        new THREE.TorusGeometry(SR * 1.015, 0.015, 12, 256),
        new THREE.MeshBasicMaterial({ color: new THREE.Color(2.0, 1.8, 1.4) })
    );
    photonRing2.rotation.x = -Math.PI / 2; // æ—‹è½¬åˆ°æ°´å¹³é¢
    diskGroup.add(photonRing2);

    // ============ å¸ç§¯ç›˜ï¼ˆå¸¦å¤šæ™®å‹’æ•ˆåº”ï¼‰ ============
    function createDisk() {
        const segsR = 8;
        const segsT = 300;
        const geom = new THREE.RingGeometry(DISK_IN, DISK_OUT, segsT, segsR);

        const pos = geom.attributes.position;
        const colors = new Float32Array(pos.count * 3);

        for (let i = 0; i < pos.count; i++) {
            const x = pos.getX(i), y = pos.getY(i);
            const r = Math.sqrt(x * x + y * y);
            const t = Math.max(0, Math.min(1, (r - DISK_IN) / (DISK_OUT - DISK_IN)));

            // äº®åº¦è¡°å‡ï¼ˆå†…äº®å¤–æš—ï¼Œé™ä½å³°å€¼é¿å… bloom æ‰©æ•£åˆ°é»‘æ´ä¸­å¿ƒï¼‰
            const baseBright = Math.pow(1 - t, 2.0) * 1.8;

            // å¤šæ™®å‹’æ•ˆåº”ï¼šå³ä¾§æ¥è¿‘è§‚å¯Ÿè€…ï¼ˆæ›´äº®æ›´è“ç§»ï¼‰ï¼Œå·¦ä¾§è¿œç¦»ï¼ˆæ›´æš—æ›´çº¢ç§»ï¼‰
            const angle = Math.atan2(y, x);
            const doppler = 1.0 + 0.35 * Math.cos(angle); // å³ä¾§å¢äº®35%

            const bright = baseBright * doppler;

            // è‰²æ¸©æ¸å˜
            let col;
            if (t < 0.15) {
                col = lerpColor(COL.hotWhite, COL.warmGold, t / 0.15);
            } else if (t < 0.5) {
                col = lerpColor(COL.warmGold, COL.deepOrange, (t - 0.15) / 0.35);
            } else {
                col = lerpColor(COL.deepOrange, COL.dimRed, (t - 0.5) / 0.5);
            }

            colors[i * 3]     = bright * col[0];
            colors[i * 3 + 1] = bright * col[1];
            colors[i * 3 + 2] = bright * col[2];
        }
        geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        return geom;
    }

    const disk = new THREE.Mesh(createDisk(), new THREE.MeshBasicMaterial({
        vertexColors: true, side: THREE.DoubleSide, transparent: true, opacity: 0.95,
    }));
    disk.rotation.x = -Math.PI / 2;
    diskGroup.add(disk);

    // å¤–å›´ææ·¡è¾‰å…‰å»¶ä¼¸
    const outerGlowGeom = new THREE.RingGeometry(DISK_OUT * 0.85, DISK_OUT * 1.6, 128, 2);
    const ogPos = outerGlowGeom.attributes.position;
    const ogCol = new Float32Array(ogPos.count * 3);
    for (let i = 0; i < ogPos.count; i++) {
        const x = ogPos.getX(i), y = ogPos.getY(i);
        const r = Math.sqrt(x * x + y * y);
        const t = (r - DISK_OUT * 0.85) / (DISK_OUT * 0.75);
        const b = Math.max(0, 0.12 * (1 - t));
        ogCol[i*3] = b * 0.9; ogCol[i*3+1] = b * 0.5; ogCol[i*3+2] = b * 0.15;
    }
    outerGlowGeom.setAttribute('color', new THREE.BufferAttribute(ogCol, 3));
    const outerGlow = new THREE.Mesh(outerGlowGeom, new THREE.MeshBasicMaterial({
        vertexColors: true, side: THREE.DoubleSide, transparent: true, opacity: 0.45,
    }));
    outerGlow.rotation.x = -Math.PI / 2;
    diskGroup.add(outerGlow);

    // ============ å†…ä¾§é«˜æ¸©å‘å…‰ç¯ ============
    const innerGlow = new THREE.Mesh(
        new THREE.TorusGeometry(DISK_IN * 0.98, 0.06, 16, 200),
        new THREE.MeshBasicMaterial({ color: new THREE.Color(1.4, 1.1, 0.7) })
    );
    innerGlow.rotation.x = Math.PI / 2;
    diskGroup.add(innerGlow);

    // ============ å¼•åŠ›é€é•œå¼§ ============
    // æ ¸å¿ƒç‰©ç†ï¼šå¼•åŠ›é€é•œå¼§æ˜¯"è§†é”™è§‰"â€”â€”è¿œå¤„ç›˜é¢çš„å…‰ç»•é»‘æ´å¼¯æ›²åæŠ•å°„åˆ°è§‚å¯Ÿè€…çœ¼ä¸­
    // åªæœ‰ä»æ¥è¿‘ç›˜é¢ï¼ˆä¾§é¢ï¼‰çš„è§’åº¦æ‰èƒ½çœ‹åˆ°ï¼Œä»ä¿¯è§†è§’åº¦ä¸ä¼šå‡ºç°
    // å› æ­¤éœ€è¦æ ¹æ®ç›¸æœºä»°è§’åŠ¨æ€è°ƒæ•´å¼§çš„ä¸é€æ˜åº¦
    function createLensingArc(yScale, halfWidth, innerR, brightness, colorMix) {
        const segs = 200;
        const verts = [];
        const cols = [];
        const idxs = [];

        for (let i = 0; i <= segs; i++) {
            const t = i / segs;         // 0â†’1 æ²¿å¼§çº¿
            const a = t * Math.PI;      // 0â†’Ï€ åŠåœ†

            // å¼§çº¿è·¯å¾„ï¼šåŠæ¤­åœ†ï¼Œxè½´æ–¹å‘è·¨è¶Šç›˜é¢
            const cosA = Math.cos(a);
            const sinA = Math.sin(a);
            const x = innerR * cosA;
            const y = SR * yScale * sinA;

            // å¼§çº¿å®½åº¦ï¼šä¸¤ç«¯è¿æ¥ç›˜é¢å¤„è¾ƒå®½ï¼Œé¡¶éƒ¨è¾ƒçª„
            const hw = halfWidth * (0.5 + 0.5 * Math.pow(sinA, 0.3));

            // äº®åº¦ï¼šä¸¤ç«¯ï¼ˆè¿æ¥ç›˜é¢ï¼‰æ›´äº® + ä¸­é—´éƒ¨åˆ†ä¹Ÿæœ‰è¾‰å…‰
            const edgeBright = Math.pow(Math.abs(cosA), 0.4);
            const centerBright = Math.pow(sinA, 0.6);
            const b = brightness * (0.4 * edgeBright + 0.7 * centerBright);

            // è‰²æ¸©ï¼šç”¨ colorMix æ§åˆ¶é‡‘è‰² vs ç™½è‰²çš„æ¯”ä¾‹
            const col = lerpColor(COL.warmGold, COL.hotWhite, colorMix * sinA);

            // ä¸Šä¸‹ä¸¤ä¸ªé¡¶ç‚¹ï¼ˆzæ–¹å‘å±•å¼€å®½åº¦ï¼‰
            verts.push(x, y, -hw, x, y, hw);
            cols.push(
                b * col[0], b * col[1], b * col[2],
                b * col[0], b * col[1], b * col[2]
            );

            if (i < segs) {
                const base = i * 2;
                idxs.push(base, base+2, base+1, base+1, base+2, base+3);
            }
        }

        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
        geom.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
        geom.setIndex(idxs);
        geom.computeVertexNormals();
        return geom;
    }

    const arcMat = new THREE.MeshBasicMaterial({
        vertexColors: true, side: THREE.DoubleSide, transparent: true, opacity: 0.85,
    });

    // æ”¶é›†æ‰€æœ‰å¼§å¯¹è±¡ï¼Œç”¨äºæ ¹æ®è§†è§’åŠ¨æ€æ§åˆ¶é€æ˜åº¦
    // æ¯ä¸ªå¼§è®°å½• { mesh, baseOpacity }
    const allArcs = [];

    // ä¸Šå¼§ï¼šä¸»è¦å¼•åŠ›é€é•œå¼§ï¼ˆé™ä½äº®åº¦ï¼Œé¿å… bloom æ·¹æ²¡ä¸­å¿ƒï¼‰
    const topArc = new THREE.Mesh(
        createLensingArc(1.35, 0.7, 2.6, 1.5, 0.6),
        arcMat
    );
    diskGroup.add(topArc);
    allArcs.push({ mesh: topArc, baseOpacity: 0.85 });

    // ä¸Šå¼§æ ¸å¿ƒäº®çº¿
    const topArcCore = new THREE.Mesh(
        createLensingArc(1.32, 0.18, 2.55, 2.5, 0.8),
        new THREE.MeshBasicMaterial({
            vertexColors: true, side: THREE.DoubleSide, transparent: true, opacity: 0.95,
        })
    );
    diskGroup.add(topArcCore);
    allArcs.push({ mesh: topArcCore, baseOpacity: 0.95 });

    // ä¸Šå¼§å¤–å±‚è¾‰å…‰
    const topArcGlow = new THREE.Mesh(
        createLensingArc(1.4, 1.2, 2.7, 0.4, 0.3),
        new THREE.MeshBasicMaterial({
            vertexColors: true, side: THREE.DoubleSide, transparent: true, opacity: 0.35,
        })
    );
    diskGroup.add(topArcGlow);
    allArcs.push({ mesh: topArcGlow, baseOpacity: 0.35 });

    // ä¸‹å¼§ï¼šè¾ƒæš—è¾ƒçª„
    const botArc = new THREE.Mesh(
        createLensingArc(-1.15, 0.4, 2.5, 1.0, 0.4),
        new THREE.MeshBasicMaterial({
            vertexColors: true, side: THREE.DoubleSide, transparent: true, opacity: 0.6,
        })
    );
    diskGroup.add(botArc);
    allArcs.push({ mesh: botArc, baseOpacity: 0.6 });

    // ä¸‹å¼§æ ¸å¿ƒäº®çº¿
    const botArcCore = new THREE.Mesh(
        createLensingArc(-1.12, 0.1, 2.45, 1.8, 0.5),
        new THREE.MeshBasicMaterial({
            vertexColors: true, side: THREE.DoubleSide, transparent: true, opacity: 0.7,
        })
    );
    diskGroup.add(botArcCore);
    allArcs.push({ mesh: botArcCore, baseOpacity: 0.7 });

    // ============ æ˜Ÿç©º ============
    function createStars() {
        const count = 5000;
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 60 + Math.random() * 120;
            positions[i*3]   = r * Math.sin(phi) * Math.cos(theta);
            positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i*3+2] = r * Math.cos(phi);

            const type = Math.random();
            if (type < 0.08) {
                // è“ç™½æ˜Ÿ
                colors[i*3] = 0.7; colors[i*3+1] = 0.8; colors[i*3+2] = 1;
            } else if (type < 0.15) {
                // é‡‘é»„æ˜Ÿ
                colors[i*3] = 1; colors[i*3+1] = 0.85; colors[i*3+2] = 0.5;
            } else {
                const b = 0.6 + Math.random() * 0.4;
                colors[i*3] = b; colors[i*3+1] = b; colors[i*3+2] = b * 0.95;
            }
        }

        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        return new THREE.Points(geom, new THREE.PointsMaterial({
            size: 0.35, vertexColors: true, sizeAttenuation: true,
            transparent: true, opacity: 0.85,
        }));
    }
    scene.add(createStars());

    // ============ å¾®å¼±æ˜Ÿäº‘ ============
    const nebula = new THREE.Mesh(
        new THREE.SphereGeometry(55, 32, 32),
        new THREE.MeshBasicMaterial({
            color: 0x0a0805, side: THREE.BackSide, transparent: true, opacity: 0.5,
        })
    );
    scene.add(nebula);

    // ============ æ ‡æ³¨äº¤äº’ ============
    const annBtns = document.querySelectorAll('.ann-btn');
    let activeHighlight = null;

    // é«˜äº®å¯¹è±¡æ˜ å°„
    const highlights = {
        singularity: { obj: bhSphere, color: new THREE.Color(0.2, 0, 0.3) },
        horizon: { obj: bhSphere },
        photon: { obj: photonRing1 },
        disk: { obj: disk },
        lens: { obj: topArc },
    };

    annBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const target = btn.dataset.target;
            // åˆ‡æ¢é«˜äº®çŠ¶æ€
            if (activeHighlight === target) {
                // å–æ¶ˆé«˜äº®
                annBtns.forEach(b => b.style.borderColor = '');
                activeHighlight = null;
                return;
            }
            annBtns.forEach(b => b.style.borderColor = '');
            btn.style.borderColor = '#ffcc66';
            activeHighlight = target;

            // ç¼“æ…¢é£å‘ç›®æ ‡
            if (target === 'singularity' || target === 'horizon') {
                smoothMoveTo(0, 1, 7);
            } else if (target === 'photon') {
                smoothMoveTo(2, 2, 8);
            } else if (target === 'disk') {
                smoothMoveTo(0, 8, 12);
            } else if (target === 'lens') {
                smoothMoveTo(0, 2, 10);
            }
        });
    });

    function smoothMoveTo(tx, ty, tz) {
        controls.autoRotate = false;
        const start = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
        const dur = 1200;
        const t0 = performance.now();
        function step() {
            const p = Math.min(1, (performance.now() - t0) / dur);
            const ease = 1 - Math.pow(1 - p, 3); // easeOutCubic
            camera.position.set(
                start.x + (tx - start.x) * ease,
                start.y + (ty - start.y) * ease,
                start.z + (tz - start.z) * ease
            );
            if (p < 1) requestAnimationFrame(step);
        }
        step();
    }

    // ============ åŠ¨ç”» ============
    let time = 0;

    function animate() {
        requestAnimationFrame(animate);
        time += 0.003;

        // ç›˜ç¼“æ…¢æ—‹è½¬
        diskGroup.rotation.y += 0.0006;

        // å…‰å­ç¯è„‰åŠ¨ï¼ˆé™ä½åçš„äº®åº¦èŒƒå›´ï¼‰
        const pulse = 1 + 0.08 * Math.sin(time * 12);
        photonRing1.material.color.setRGB(1.6 * pulse, 1.3 * pulse, 0.9 * pulse);
        photonRing2.material.color.setRGB(2.0 * pulse, 1.8 * pulse, 1.4 * pulse);

        // ====== è§†è§’ä¾èµ–ï¼šå¼•åŠ›é€é•œå¼§éšä»°è§’æ·¡å‡º ======
        // elevation = 0 è¡¨ç¤ºä»ä¾§é¢çœ‹ï¼ˆç›˜é¢æ–¹å‘ï¼‰ï¼Œ= 1 è¡¨ç¤ºä»æ­£ä¸Š/æ­£ä¸‹æ–¹çœ‹
        // å¼•åŠ›é€é•œæ˜¯å…‰å­¦ç°è±¡ï¼Œåªæœ‰ä»ä¾§é¢æ‰èƒ½çœ‹åˆ°
        const camPos = camera.position.clone().normalize();
        const elevation = Math.abs(camPos.y); // 0~1
        // ä»°è§’ < 20Â° æ—¶å¼§å®Œå…¨å¯è§ï¼Œ> 55Â° æ—¶å®Œå…¨æ¶ˆå¤±
        const arcFade = Math.max(0, Math.min(1, (0.50 - elevation) / 0.30));
        for (const arc of allArcs) {
            arc.mesh.material.opacity = arc.baseOpacity * arcFade;
            arc.mesh.visible = arcFade > 0.01; // å½»åº•éšè—ï¼Œé¿å…æ®‹å½±
        }

        controls.update();
        composer.render();
    }

    // ============ å“åº”å¼ ============
    window.addEventListener('resize', () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        composer.setSize(w, h);
    });

    // ============ å¯åŠ¨ ============
    document.getElementById('loading').classList.add('done');
    animate();
    setTimeout(() => document.getElementById('hint').classList.add('hide'), 5000);

    } // end init
    </script>
</body>
</html>
