<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ä¸­å›½çœä»½æ‹¼å›¾ - è®¤è¯†ç¥–å›½</title>
    <link rel="preconnect" href="https://fonts.loli.net">
    <link rel="preconnect" href="https://fonts.loli.net" crossorigin>
    <link href="https://fonts.loli.net/css2?family=Noto+Sans+SC:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #0a0a1a;
            --bg-gradient: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%);
            --primary-cyan: #00d9ff;
            --primary-yellow: #ffd93d;
            --primary-green: #26de81;
            --primary-red: #ff6b6b;
            --text-white: #ffffff;
            --text-light: rgba(255, 255, 255, 0.8);
        }

        body {
            font-family: 'Noto Sans SC', sans-serif;
            background: var(--bg-gradient);
            color: var(--text-white);
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* æ˜Ÿç©ºèƒŒæ™¯ */
        .stars-bg {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* é¡¶éƒ¨å¯¼èˆª */
        .top-nav {
            position: fixed;
            top: 0; left: 0; right: 0;
            z-index: 100;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(10,10,26,0.98) 0%, rgba(10,10,26,0.8) 70%, transparent 100%);
        }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            text-decoration: none;
            cursor: pointer;
        }

        .title-area h1 {
            font-size: 1.3rem;
            font-weight: 900;
            color: var(--primary-cyan);
        }

        .stats-area {
            display: flex;
            gap: 10px;
        }
        .stat-box {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 12px;
            background: rgba(0,217,255,0.15);
            border: 2px solid var(--primary-cyan);
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        .stat-box.progress {
            background: rgba(255,217,61,0.15);
            border-color: var(--primary-yellow);
        }

        /* ä¸»æ¸¸æˆåŒºåŸŸ */
        .game-container {
            position: fixed;
            top: 55px;
            left: 0; right: 0; bottom: 0;
            display: flex;
            z-index: 1;
        }

        /* åœ°å›¾åŒºåŸŸ */
        .map-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            min-height: 0;
        }

        #mapContainer {
            width: 100%;
            height: 100%;
            max-width: 750px;
            position: relative;
        }

        #mapContainer svg {
            width: 100%;
            height: 100%;
        }

        /* ç›®æ ‡è½®å»“æ ·å¼ */
        .state.target {
            fill: rgba(255,255,255,0.08) !important;
            stroke: rgba(255,255,255,0.3);
            stroke-width: 0.5;
            stroke-dasharray: 3 2;
            cursor: default;
        }
        .state.target.highlight {
            fill: rgba(255,217,61,0.3) !important;
            stroke: var(--primary-yellow);
            stroke-width: 2;
            stroke-dasharray: none;
        }
        .state.placed {
            cursor: pointer;
            stroke: #ffffff;
            stroke-width: 1;
        }

        /* æ‹¼å›¾å—åŒºåŸŸ */
        .puzzle-area {
            width: 320px;
            min-width: 320px;
            background: linear-gradient(270deg, rgba(10,10,26,0.98) 0%, rgba(10,10,26,0.9) 90%, transparent 100%);
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .puzzle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 0 5px;
        }

        .puzzle-title {
            font-size: 0.85rem;
            color: var(--primary-cyan);
            font-weight: 700;
        }

        .puzzle-controls {
            display: flex;
            gap: 6px;
        }

        .control-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 5px 10px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
        }
        .control-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        /* æ‹¼å›¾å—æ»šåŠ¨å®¹å™¨ */
        .puzzle-scroll {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 5px;
            align-content: flex-start;
        }

        .puzzle-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .puzzle-scroll::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        .puzzle-scroll::-webkit-scrollbar-thumb {
            background: var(--primary-cyan);
            border-radius: 3px;
        }

        /* æ‹¼å›¾å— - çœä»½å½¢çŠ¶å®¹å™¨ */
        .puzzle-piece {
            position: relative;
            cursor: grab;
            transition: transform 0.2s ease, filter 0.2s ease;
        }
        .puzzle-piece:hover {
            transform: scale(1.08);
            filter: brightness(1.2);
            z-index: 10;
        }
        .puzzle-piece.dragging {
            cursor: grabbing;
            opacity: 0.7;
            z-index: 100;
        }
        .puzzle-piece.placed {
            display: none;
        }
        .puzzle-piece svg {
            display: block;
        }
        .puzzle-piece .province-shape {
            stroke: #ffffff;
            stroke-width: 1.5;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5));
        }

        /* çœä»½æ ‡ç­¾ */
        .piece-label {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8), -1px -1px 3px rgba(0,0,0,0.8);
        }
        .piece-emoji {
            font-size: 1.2rem;
            display: block;
        }
        .piece-name {
            font-size: 0.65rem;
            font-weight: 700;
            color: white;
            white-space: nowrap;
        }

        /* æ‹–æ‹½å¹½çµ */
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 2000;
            opacity: 0.9;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
        }
        .drag-ghost svg {
            display: block;
        }
        .drag-ghost .province-shape {
            stroke: var(--primary-yellow);
            stroke-width: 3;
        }
        .drag-ghost .piece-label {
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
        }

        /* çœä»½ä¿¡æ¯å¼¹çª— */
        .modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        .modal.visible { display: flex; }

        .modal-content {
            background: linear-gradient(135deg, #1a1a3a, #0a0a2a);
            border: 3px solid var(--primary-cyan);
            border-radius: 25px;
            padding: 25px;
            max-width: 380px;
            width: 90%;
            position: relative;
            animation: modalIn 0.3s ease;
        }

        @keyframes modalIn {
            from { opacity: 0; transform: scale(0.9) translateY(20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .modal-close {
            position: absolute;
            top: 12px; right: 12px;
            width: 32px; height: 32px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 1.1rem;
            cursor: pointer;
        }

        .province-header {
            text-align: center;
            margin-bottom: 20px;
        }
        .province-icon { font-size: 3.5rem; }
        .province-header h2 {
            font-size: 1.8rem;
            color: var(--primary-yellow);
            margin: 8px 0 5px;
        }
        .province-type {
            font-size: 0.85rem;
            color: var(--text-light);
            padding: 4px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            display: inline-block;
        }

        .detail-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            margin-bottom: 10px;
        }
        .detail-emoji { font-size: 2rem; }
        .detail-label { font-size: 0.8rem; color: var(--text-light); }
        .detail-value { font-size: 1.1rem; font-weight: 700; }

        .fun-fact {
            padding: 12px;
            background: linear-gradient(135deg, rgba(155,89,182,0.2), rgba(142,68,173,0.2));
            border: 2px solid #9b59b6;
            border-radius: 12px;
            text-align: center;
            margin-top: 10px;
        }
        .fun-fact-title { font-size: 0.85rem; color: #9b59b6; margin-bottom: 6px; }

        /* å®Œæˆå¼¹çª— */
        .celebration-icon {
            font-size: 4rem;
            animation: bounce 0.5s ease infinite alternate;
        }
        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-8px); }
        }

        .knowledge-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px solid rgba(255,255,255,0.1);
        }
        .knowledge-title {
            font-size: 1rem;
            color: var(--primary-cyan);
            margin-bottom: 12px;
            text-align: center;
        }
        .knowledge-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .knowledge-item {
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            text-align: center;
        }
        .knowledge-number {
            font-size: 1.4rem;
            font-weight: 900;
            color: var(--primary-yellow);
        }
        .knowledge-label { font-size: 0.8rem; color: var(--text-light); }

        .play-again-btn {
            padding: 12px 35px;
            background: linear-gradient(135deg, var(--primary-cyan), var(--primary-green));
            border: none;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 700;
            color: white;
            cursor: pointer;
            margin-top: 15px;
        }

        /* Toast */
        .toast {
            position: fixed;
            top: 65px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            z-index: 1000;
            border: 2px solid var(--primary-cyan);
            animation: toastIn 0.3s ease;
        }
        @keyframes toastIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* åŠ è½½ */
        .loading {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-gradient);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .loading.hidden { display: none; }
        .loading-icon { font-size: 4rem; animation: spin 2s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .loading-text { margin-top: 15px; font-size: 1.2rem; color: var(--primary-cyan); }
    </style>
</head>

<body>
    <!-- åŠ è½½ç•Œé¢ -->
    <div class="loading" id="loadingScreen">
        <div class="loading-icon">ğŸ—ºï¸</div>
        <div class="loading-text">æ­£åœ¨åŠ è½½ä¸­å›½åœ°å›¾...</div>
    </div>

    <!-- æ˜Ÿç©ºèƒŒæ™¯ -->
    <div class="stars-bg" id="starsBg"></div>

    <!-- é¡¶éƒ¨å¯¼èˆª -->
    <header class="top-nav">
        <a href="../index.html" class="back-btn">â¬…ï¸ è¿”å›</a>
        <div class="title-area">
            <h1>ğŸ—ºï¸ ä¸­å›½çœä»½æ‹¼å›¾</h1>
        </div>
        <div class="stats-area">
            <div class="stat-box">â±ï¸ <span id="timerText">0:00</span></div>
            <div class="stat-box progress">ğŸ§© <span id="progressText">0/34</span></div>
        </div>
    </header>

    <!-- ä¸»æ¸¸æˆåŒºåŸŸ -->
    <main class="game-container">
        <!-- åœ°å›¾åŒºåŸŸ -->
        <div class="map-area">
            <div id="mapContainer"></div>
        </div>

        <!-- æ‹¼å›¾å—åŒºåŸŸ -->
        <div class="puzzle-area">
            <div class="puzzle-header">
                <span class="puzzle-title">ğŸ§© æ‹–æ‹½çœä»½åˆ°åœ°å›¾</span>
                <div class="puzzle-controls">
                    <button class="control-btn" id="hintBtn">ğŸ’¡æç¤º</button>
                    <button class="control-btn" id="resetBtn">ğŸ”„é‡ç½®</button>
                </div>
            </div>
            <div class="puzzle-scroll" id="puzzleScroll"></div>
        </div>
    </main>

    <!-- æ‹–æ‹½å¹½çµ -->
    <div class="drag-ghost" id="dragGhost" style="display: none;"></div>

    <!-- çœä»½ä¿¡æ¯å¼¹çª— -->
    <div class="modal" id="provinceModal">
        <div class="modal-content">
            <button class="modal-close" id="modalClose">âœ•</button>
            <div class="province-header">
                <div class="province-icon" id="provinceIcon">ğŸ›ï¸</div>
                <h2 id="provinceName">åŒ—äº¬</h2>
                <span class="province-type" id="provinceType">ç›´è¾–å¸‚</span>
            </div>
            <div class="detail-item">
                <span class="detail-emoji" id="foodEmoji">ğŸ¦†</span>
                <div>
                    <div class="detail-label">ç‰¹è‰²ç¾é£Ÿ</div>
                    <div class="detail-value" id="foodName">åŒ—äº¬çƒ¤é¸­</div>
                </div>
            </div>
            <div class="detail-item">
                <span class="detail-emoji" id="landmarkEmoji">ğŸ¯</span>
                <div>
                    <div class="detail-label">è‘—åæ™¯ç‚¹</div>
                    <div class="detail-value" id="landmarkName">é•¿åŸ</div>
                </div>
            </div>
            <div class="fun-fact">
                <div class="fun-fact-title">ğŸ’¡ ä½ çŸ¥é“å—ï¼Ÿ</div>
                <div id="funFactText">åŒ—äº¬æ˜¯ä¸­å›½çš„é¦–éƒ½ï¼</div>
            </div>
        </div>
    </div>

    <!-- å®Œæˆå¼¹çª— -->
    <div class="modal" id="completionModal">
        <div class="modal-content" style="text-align: center;">
            <div class="celebration-icon">ğŸ‰</div>
            <h2 style="color: var(--primary-yellow); margin: 15px 0;">å¤ªæ£’äº†ï¼</h2>
            <p>ä½ å®Œæˆäº†ä¸­å›½åœ°å›¾æ‹¼å›¾ï¼</p>
            <div style="display: flex; justify-content: center; gap: 25px; margin: 20px 0;">
                <div style="text-align: center;">
                    <div style="font-size: 1.8rem; font-weight: 900; color: var(--primary-cyan);" id="completionTime">0:00</div>
                    <div style="font-size: 0.85rem; color: var(--text-light);">ç”¨æ—¶</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.8rem; font-weight: 900; color: var(--primary-cyan);">34</div>
                    <div style="font-size: 0.85rem; color: var(--text-light);">çœä»½</div>
                </div>
            </div>
            <div class="knowledge-section">
                <div class="knowledge-title">ğŸ“ ä¸­å›½è¡Œæ”¿åŒºåˆ’</div>
                <div class="knowledge-grid">
                    <div class="knowledge-item">
                        <div class="knowledge-number">23</div>
                        <div class="knowledge-label">ä¸ªçœ</div>
                    </div>
                    <div class="knowledge-item">
                        <div class="knowledge-number">5</div>
                        <div class="knowledge-label">ä¸ªè‡ªæ²»åŒº</div>
                    </div>
                    <div class="knowledge-item">
                        <div class="knowledge-number">4</div>
                        <div class="knowledge-label">ä¸ªç›´è¾–å¸‚</div>
                    </div>
                    <div class="knowledge-item">
                        <div class="knowledge-number">2</div>
                        <div class="knowledge-label">ä¸ªç‰¹åˆ«è¡Œæ”¿åŒº</div>
                    </div>
                </div>
                <p style="margin-top: 12px; font-size: 1rem; color: var(--primary-yellow);">
                    23 + 5 + 4 + 2 = <strong>34</strong>
                </p>
            </div>
            <button class="play-again-btn" id="playAgainBtn">å†ç©ä¸€æ¬¡ ğŸ”„</button>
        </div>
    </div>

    <script src="js/province-info.js"></script>
    <script>
        // ============ å…¨å±€å˜é‡ ============
        let svgDoc = null;
        let provinces = {};
        let placedCount = 0;
        let startTime = Date.now();
        let timerInterval = null;
        let currentDragging = null;
        let dragGhost = null;

        // æ‹¼å›¾å—å°ºå¯¸é…ç½®
        const PIECE_MAX_SIZE = 70; // æœ€å¤§å°ºå¯¸

        // ============ åˆå§‹åŒ– ============
        async function init() {
            generateStars();
            await loadMap();
            setupGame();
            bindEvents();
            startTimer();

            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
            }, 500);
        }

        // ============ ç”Ÿæˆæ˜Ÿç©º ============
        function generateStars() {
            const bg = document.getElementById('starsBg');
            for (let i = 0; i < 50; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = (Math.random() * 2 + 1) + 'px';
                star.style.animationDelay = Math.random() * 2 + 's';
                bg.appendChild(star);
            }
        }

        // ============ åŠ è½½åœ°å›¾ ============
        async function loadMap() {
            const response = await fetch('china-map.svg');
            const svgText = await response.text();
            document.getElementById('mapContainer').innerHTML = svgText;
            svgDoc = document.querySelector('#mapContainer svg');
            svgDoc.setAttribute('viewBox', '0 0 595.28 504');
        }

        // ============ è®¾ç½®æ¸¸æˆ ============
        function setupGame() {
            const puzzleScroll = document.getElementById('puzzleScroll');
            puzzleScroll.innerHTML = '';

            // è·å–æ‰€æœ‰çœä»½å…ƒç´ 
            const stateElements = svgDoc.querySelectorAll('.state');

            stateElements.forEach(el => {
                const classes = el.getAttribute('class').split(' ');
                const stateClass = classes.find(c => c !== 'state');
                if (!stateClass) return;

                const info = ProvinceInfo[stateClass];
                if (!info) return;

                // è®¾ç½®ä¸ºç›®æ ‡è½®å»“
                el.classList.add('target');
                el.setAttribute('data-province', stateClass);

                // è·å–çœä»½è¾¹ç•Œæ¡†
                const bbox = el.getBBox();

                // ä¿å­˜çœä»½ä¿¡æ¯
                provinces[stateClass] = {
                    targetElement: el,
                    info: info,
                    placed: false,
                    bbox: bbox,
                    pathData: el.getAttribute('d') || null,
                    points: el.getAttribute('points') || null,
                    tagName: el.tagName.toLowerCase()
                };
            });

            // åˆ›å»ºæ‹¼å›¾å—ï¼ˆéšæœºé¡ºåºï¼‰
            const provinceKeys = Object.keys(provinces);
            shuffleArray(provinceKeys);

            provinceKeys.forEach(key => {
                const province = provinces[key];
                const piece = createPuzzlePiece(key, province);
                puzzleScroll.appendChild(piece);
                provinces[key].pieceElement = piece;
            });
        }

        // ============ åˆ›å»ºæ‹¼å›¾å—ï¼ˆçœŸå®çœä»½å½¢çŠ¶ï¼‰============
        function createPuzzlePiece(key, province) {
            const info = province.info;
            const bbox = province.bbox;

            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œä½¿æ‹¼å›¾å—é€‚åº”æŒ‡å®šå¤§å°
            const scale = Math.min(PIECE_MAX_SIZE / bbox.width, PIECE_MAX_SIZE / bbox.height);
            const width = bbox.width * scale;
            const height = bbox.height * scale;

            // åˆ›å»ºå®¹å™¨
            const piece = document.createElement('div');
            piece.className = 'puzzle-piece';
            piece.setAttribute('data-province', key);
            piece.style.width = width + 'px';
            piece.style.height = height + 'px';

            // åˆ›å»ºSVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.setAttribute('viewBox', `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);

            // å¤åˆ¶çœä»½å½¢çŠ¶
            let shape;
            if (province.tagName === 'path') {
                shape = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                shape.setAttribute('d', province.pathData);
            } else {
                shape = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                shape.setAttribute('points', province.points);
            }
            shape.classList.add('province-shape');
            shape.setAttribute('fill', info.color);

            svg.appendChild(shape);
            piece.appendChild(svg);

            // æ·»åŠ æ ‡ç­¾ï¼ˆemoji + åç§°ï¼‰
            const label = document.createElement('div');
            label.className = 'piece-label';
            label.innerHTML = `
                <span class="piece-emoji">${info.landmark.emoji}</span>
                <span class="piece-name">${info.name}</span>
            `;
            piece.appendChild(label);

            // å­˜å‚¨ç¼©æ”¾ä¿¡æ¯
            province.scale = scale;
            province.pieceWidth = width;
            province.pieceHeight = height;

            return piece;
        }

        // ============ æ‰“ä¹±æ•°ç»„ ============
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // ============ ç»‘å®šäº‹ä»¶ ============
        function bindEvents() {
            dragGhost = document.getElementById('dragGhost');

            // é¼ æ ‡äº‹ä»¶
            document.addEventListener('mousedown', handleDragStart);
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);

            // è§¦æ‘¸äº‹ä»¶
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);

            // æ§åˆ¶æŒ‰é’®
            document.getElementById('hintBtn').onclick = showHint;
            document.getElementById('resetBtn').onclick = resetGame;
            document.getElementById('playAgainBtn').onclick = () => {
                document.getElementById('completionModal').classList.remove('visible');
                resetGame();
            };

            // å¼¹çª—å…³é—­
            document.getElementById('modalClose').onclick = () => {
                document.getElementById('provinceModal').classList.remove('visible');
            };
            document.getElementById('provinceModal').onclick = (e) => {
                if (e.target.id === 'provinceModal') {
                    document.getElementById('provinceModal').classList.remove('visible');
                }
            };
        }

        // ============ æ‹–æ‹½å¤„ç† ============
        function handleDragStart(e) {
            const piece = e.target.closest('.puzzle-piece');
            if (!piece || piece.classList.contains('placed')) return;

            e.preventDefault();
            const key = piece.getAttribute('data-province');
            const province = provinces[key];

            currentDragging = {
                key: key,
                piece: piece,
                province: province
            };

            piece.classList.add('dragging');

            // åˆ›å»ºå¹½çµå…ƒç´ ï¼ˆå¤åˆ¶æ‹¼å›¾å—ï¼‰
            dragGhost.innerHTML = piece.innerHTML;
            dragGhost.style.width = province.pieceWidth + 'px';
            dragGhost.style.height = province.pieceHeight + 'px';
            dragGhost.style.display = 'block';

            updateGhostPosition(e.clientX, e.clientY);

            // é«˜äº®ç›®æ ‡
            province.targetElement.classList.add('highlight');
        }

        function handleDragMove(e) {
            if (!currentDragging) return;
            e.preventDefault();
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            updateGhostPosition(e.clientX, e.clientY);
            checkHover(e.clientX, e.clientY);
        }

        // ä¿å­˜æœ€åçš„é¼ æ ‡ä½ç½®
        let lastMouseX = 0;
        let lastMouseY = 0;

        function handleDragEnd(e) {
            if (!currentDragging) return;

            const key = currentDragging.key;
            const piece = currentDragging.piece;
            const province = currentDragging.province;

            // è·å–æœ€ç»ˆä½ç½®ï¼ˆä½¿ç”¨ä¿å­˜çš„é¼ æ ‡ä½ç½®ï¼‰
            const dropX = lastMouseX;
            const dropY = lastMouseY;

            piece.classList.remove('dragging');
            dragGhost.style.display = 'none';
            province.targetElement.classList.remove('highlight');
            province.targetElement.style.fill = '';
            province.targetElement.style.stroke = '';

            // è½¬æ¢ä¸ºSVGåæ ‡
            const point = svgDoc.createSVGPoint();
            point.x = dropX;
            point.y = dropY;
            const svgPoint = point.matrixTransform(svgDoc.getScreenCTM().inverse());

            // æ£€æŸ¥æ˜¯å¦åœ¨ç›®æ ‡åŒºåŸŸå†…
            const bbox = province.bbox;
            const margin = 30; // å¢åŠ å®¹é”™è¾¹è·
            const isInside =
                svgPoint.x >= bbox.x - margin &&
                svgPoint.x <= bbox.x + bbox.width + margin &&
                svgPoint.y >= bbox.y - margin &&
                svgPoint.y <= bbox.y + bbox.height + margin;

            if (isInside) {
                placeProvince(key);
            }

            currentDragging = null;
        }

        // ============ è§¦æ‘¸äº‹ä»¶ ============
        function handleTouchStart(e) {
            if (e.touches.length !== 1) return;
            const touch = e.touches[0];
            const elem = document.elementFromPoint(touch.clientX, touch.clientY);
            const piece = elem ? elem.closest('.puzzle-piece') : null;
            if (!piece) return;

            handleDragStart({
                target: piece,
                clientX: touch.clientX,
                clientY: touch.clientY,
                preventDefault: () => e.preventDefault()
            });
        }

        function handleTouchMove(e) {
            if (!currentDragging || e.touches.length !== 1) return;
            e.preventDefault();
            const touch = e.touches[0];
            lastMouseX = touch.clientX;
            lastMouseY = touch.clientY;
            updateGhostPosition(touch.clientX, touch.clientY);
            checkHover(touch.clientX, touch.clientY);
        }

        function handleTouchEnd(e) {
            handleDragEnd(e);
        }

        // ============ è¾…åŠ©å‡½æ•° ============
        function updateGhostPosition(x, y) {
            dragGhost.style.left = x + 'px';
            dragGhost.style.top = y + 'px';
        }

        function checkHover(x, y) {
            if (!currentDragging) return;

            const province = currentDragging.province;
            const point = svgDoc.createSVGPoint();
            point.x = x;
            point.y = y;
            const svgPoint = point.matrixTransform(svgDoc.getScreenCTM().inverse());

            const bbox = province.bbox;
            const margin = 20;
            const isNear =
                svgPoint.x >= bbox.x - margin &&
                svgPoint.x <= bbox.x + bbox.width + margin &&
                svgPoint.y >= bbox.y - margin &&
                svgPoint.y <= bbox.y + bbox.height + margin;

            if (isNear) {
                province.targetElement.style.fill = 'rgba(38, 222, 129, 0.4)';
                province.targetElement.style.stroke = '#26de81';
            } else {
                province.targetElement.style.fill = '';
                province.targetElement.style.stroke = '';
            }
        }

        function placeProvince(key) {
            const province = provinces[key];

            // éšè—æ‹¼å›¾å—
            province.pieceElement.classList.add('placed');

            // è®¾ç½®ç›®æ ‡æ ·å¼
            province.targetElement.classList.remove('target');
            province.targetElement.classList.remove('highlight');
            province.targetElement.classList.add('placed');
            province.targetElement.setAttribute('fill', province.info.color);
            province.targetElement.style.fill = '';
            province.targetElement.style.stroke = '';

            // åœ¨åœ°å›¾ä¸Šæ·»åŠ çœä»½æ ‡ç­¾ï¼ˆemoji + åç§°ï¼‰
            addProvinceLabel(key, province);

            // ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…
            province.targetElement.onclick = () => showProvinceInfo(province.info);

            province.placed = true;
            placedCount++;
            updateProgress();
            showToast(`âœ… ${province.info.name} æ”¾å¯¹äº†ï¼`);
            playSound('success');

            // æ’­æ”¾çœä»½ä»‹ç»è¯­éŸ³
            const info = province.info;
            const fallbackText = `${info.name}ï¼Œç¾é£Ÿæ˜¯${info.food.name}ï¼Œè‘—åæ™¯ç‚¹æœ‰${info.landmark.name}ã€‚${info.funFact}`;
            playProvinceAudio(key, fallbackText);

            if (placedCount >= Object.keys(provinces).length) {
                setTimeout(showCompletion, 500);
            }
        }

        // åœ¨åœ°å›¾ä¸Šæ·»åŠ çœä»½æ ‡ç­¾
        function addProvinceLabel(key, province) {
            const bbox = province.bbox;
            const info = province.info;

            // è®¡ç®—çœä»½ä¸­å¿ƒä½ç½®
            const centerX = bbox.x + bbox.width / 2;
            const centerY = bbox.y + bbox.height / 2;

            // æ ¹æ®çœä»½å¤§å°è°ƒæ•´å­—ä½“
            const size = Math.min(bbox.width, bbox.height);
            const fontSize = Math.max(8, Math.min(16, size / 4));
            const emojiSize = Math.max(12, Math.min(24, size / 3));

            // åˆ›å»ºforeignObjectæ¥æ˜¾ç¤ºHTMLå†…å®¹
            const fo = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
            fo.setAttribute('x', centerX - 30);
            fo.setAttribute('y', centerY - 20);
            fo.setAttribute('width', 60);
            fo.setAttribute('height', 40);
            fo.setAttribute('class', 'province-label-fo');
            fo.setAttribute('data-province', key);
            fo.style.pointerEvents = 'none'; // å…è®¸ç‚¹å‡»ç©¿é€åˆ°åº•å±‚çœä»½

            // åˆ›å»ºæ ‡ç­¾å†…å®¹
            const div = document.createElement('div');
            div.style.cssText = `
                width: 100%;
                height: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                text-align: center;
                pointer-events: none;
            `;
            div.innerHTML = `
                <span style="font-size: ${emojiSize}px; line-height: 1; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">${info.landmark.emoji}</span>
                <span style="font-size: ${fontSize}px; font-weight: bold; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.9), -1px -1px 2px rgba(0,0,0,0.9); white-space: nowrap;">${info.name}</span>
            `;

            fo.appendChild(div);
            svgDoc.appendChild(fo);

            // ä¿å­˜æ ‡ç­¾å¼•ç”¨
            province.labelElement = fo;
        }

        function updateProgress() {
            document.getElementById('progressText').textContent = `${placedCount}/34`;
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                const seconds = Math.floor((Date.now() - startTime) / 1000);
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                document.getElementById('timerText').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            }, 1000);
        }

        function resetGame() {
            Object.keys(provinces).forEach(key => {
                const province = provinces[key];
                province.placed = false;
                province.pieceElement.classList.remove('placed');
                province.targetElement.classList.add('target');
                province.targetElement.classList.remove('placed');
                province.targetElement.classList.remove('highlight');
                province.targetElement.removeAttribute('fill');
                province.targetElement.style.fill = '';
                province.targetElement.style.stroke = '';
                province.targetElement.onclick = null;

                // ç§»é™¤æ ‡ç­¾
                if (province.labelElement) {
                    province.labelElement.remove();
                    province.labelElement = null;
                }
            });

            // é‡æ–°æ‰“ä¹±
            const puzzleScroll = document.getElementById('puzzleScroll');
            const pieces = Array.from(puzzleScroll.children);
            shuffleArray(pieces);
            pieces.forEach(piece => puzzleScroll.appendChild(piece));

            placedCount = 0;
            updateProgress();
            startTime = Date.now();
        }

        function showHint() {
            const unplaced = Object.entries(provinces).filter(([k, p]) => !p.placed);
            if (unplaced.length === 0) return;

            const [key, province] = unplaced[Math.floor(Math.random() * unplaced.length)];
            province.targetElement.classList.add('highlight');
            province.pieceElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            province.pieceElement.style.animation = 'pulse 0.4s ease 3';

            showToast(`ğŸ’¡ æ‰¾æ‰¾ ${province.info.name}ï¼ˆ${province.info.landmark.emoji}ï¼‰`);

            setTimeout(() => {
                if (!province.placed) {
                    province.targetElement.classList.remove('highlight');
                }
                province.pieceElement.style.animation = '';
            }, 3000);
        }

        function showProvinceInfo(info) {
            document.getElementById('provinceIcon').textContent = info.landmark.emoji;
            document.getElementById('provinceName').textContent = info.name;
            document.getElementById('provinceType').textContent = info.type;
            document.getElementById('foodEmoji').textContent = info.food.emoji;
            document.getElementById('foodName').textContent = info.food.name;
            document.getElementById('landmarkEmoji').textContent = info.landmark.emoji;
            document.getElementById('landmarkName').textContent = info.landmark.name;
            document.getElementById('funFactText').textContent = info.funFact;
            document.getElementById('provinceModal').classList.add('visible');
        }

        function showCompletion() {
            const seconds = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            document.getElementById('completionTime').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            document.getElementById('completionModal').classList.add('visible');
            playSound('complete');
        }

        function showToast(message) {
            const existing = document.querySelector('.toast');
            if (existing) existing.remove();

            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        // ============ çœä»½è¯­éŸ³æœ—è¯»åŠŸèƒ½ ============
        // éŸ³é¢‘ç¼“å­˜
        const audioCache = {};

        // æ’­æ”¾çœä»½ä»‹ç»è¯­éŸ³
        function playProvinceAudio(provinceId, fallbackText) {
            const audioPath = `audio/provinces/${provinceId}.mp3`;
            let audio = audioCache[audioPath];
            if (!audio) {
                audio = new Audio(audioPath);
                audioCache[audioPath] = audio;
            }

            audio.currentTime = 0;
            audio.onerror = () => {
                console.log('éŸ³é¢‘åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨ TTS å¤‡é€‰:', audioPath);
                speak(fallbackText);
            };
            audio.play().catch(() => speak(fallbackText));
        }

        // Web Speech API å¤‡é€‰
        function speak(text) {
            if (!('speechSynthesis' in window)) return;
            speechSynthesis.cancel();
            setTimeout(() => {
                const u = new SpeechSynthesisUtterance(text);
                u.lang = 'zh-CN';
                u.rate = 0.9;
                speechSynthesis.speak(u);
            }, 50);
        }

        function playSound(type) {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                gain.gain.value = 0.1;

                if (type === 'success') {
                    osc.frequency.value = 800;
                    osc.start();
                    osc.stop(ctx.currentTime + 0.15);
                } else if (type === 'complete') {
                    [523, 659, 784, 1047].forEach((f, i) => {
                        setTimeout(() => {
                            const o = ctx.createOscillator();
                            const g = ctx.createGain();
                            o.connect(g);
                            g.connect(ctx.destination);
                            o.frequency.value = f;
                            g.gain.value = 0.1;
                            o.start();
                            o.stop(ctx.currentTime + 0.2);
                        }, i * 150);
                    });
                }
            } catch (e) {}
        }

        // è„‰å†²åŠ¨ç”»
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.15); filter: brightness(1.3); }
            }
        `;
        document.head.appendChild(style);

        // å¯åŠ¨
        init();
    </script>
</body>

</html>
